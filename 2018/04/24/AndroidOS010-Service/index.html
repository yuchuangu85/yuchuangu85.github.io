<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Android系统源码分析--Service启动流程 | 墨香博客</title><meta name="author" content="墨香"><meta name="copyright" content="墨香"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在前面文章我们分析了四大组件中的两个：Broadcast和Activity，这章我们分析四大组件中的服务（Service）的启动过程。Service的启动方式有两种：一种是startService，一种是bindService；第一种通常是开启一个服务执行后台任务，不进行通信，第二章通过是启动服务进行通信。下面我们就根据这两种启动方式来讲Service的启动流程以及unbindService和s">
<meta property="og:type" content="article">
<meta property="og:title" content="Android系统源码分析--Service启动流程">
<meta property="og:url" content="http://www.codemx.cn/2018/04/24/AndroidOS010-Service/index.html">
<meta property="og:site_name" content="墨香博客">
<meta property="og:description" content="在前面文章我们分析了四大组件中的两个：Broadcast和Activity，这章我们分析四大组件中的服务（Service）的启动过程。Service的启动方式有两种：一种是startService，一种是bindService；第一种通常是开启一个服务执行后台任务，不进行通信，第二章通过是启动服务进行通信。下面我们就根据这两种启动方式来讲Service的启动流程以及unbindService和s">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.codemx.cn/img/head.jpg">
<meta property="article:published_time" content="2018-04-24T12:32:23.000Z">
<meta property="article:modified_time" content="2024-07-12T16:41:32.275Z">
<meta property="article:author" content="墨香">
<meta property="article:tag" content="AndroidOS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.codemx.cn/img/head.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.codemx.cn/2018/04/24/AndroidOS010-Service/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>(()=>{
      const saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
      
      window.btf = {
        saveToLocal: saveToLocal,
        getScript: (url, attr = {}) => new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = url
          script.async = true
          script.onerror = reject
          script.onload = script.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            script.onload = script.onreadystatechange = null
            resolve()
          }

          Object.keys(attr).forEach(key => {
            script.setAttribute(key, attr[key])
          })

          document.head.appendChild(script)
        }),

        getCSS: (url, id = false) => new Promise((resolve, reject) => {
          const link = document.createElement('link')
          link.rel = 'stylesheet'
          link.href = url
          if (id) link.id = id
          link.onerror = reject
          link.onload = link.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            link.onload = link.onreadystatechange = null
            resolve()
          }
          document.head.appendChild(link)
        }),

        addGlobalFn: (key, fn, name = false, parent = window) => {
          const pjaxEnable = false
          if (!pjaxEnable && key.startsWith('pjax')) return

          const globalFn = parent.globalFn || {}
          const keyObj = globalFn[key] || {}
    
          if (name && keyObj[name]) return
    
          name = name || Object.keys(keyObj).length
          keyObj[name] = fn
          globalFn[key] = keyObj
          parent.globalFn = globalFn
        }
      }
    
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode
      
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Android系统源码分析--Service启动流程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-13 00:41:32'
}</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg" style="background-image: url(/img/bg.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img fixed" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="墨香博客"><span class="site-name">墨香博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Android系统源码分析--Service启动流程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2018-04-24T12:32:23.000Z" title="发表于 2018-04-24 20:32:23">2018-04-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-12T16:41:32.275Z" title="更新于 2024-07-13 00:41:32">2024-07-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AndroidOS/">AndroidOS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Android系统源码分析--Service启动流程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><blockquote>
<p>在前面文章我们分析了四大组件中的两个：Broadcast和Activity，这章我们分析四大组件中的服务（Service）的启动过程。Service的启动方式有两种：一种是startService，一种是bindService；第一种通常是开启一个服务执行后台任务，不进行通信，第二章通过是启动服务进行通信。下面我们就根据这两种启动方式来讲Service的启动流程以及unbindService和stopService流程。</p>
</blockquote>
<span id="more"></span>

<h2 id="Service启动流程-startService"><a href="#Service启动流程-startService" class="headerlink" title="Service启动流程-startService"></a>Service启动流程-startService</h2><p>首先来看启动流程时序图：</p>
<p><img src="/images/AndroidOS/008Service/Service1.jpg" alt="Service启动时序图"></p>
<h4 id="Step0-ContextImpl-startService"><a href="#Step0-ContextImpl-startService" class="headerlink" title="Step0.ContextImpl.startService"></a>Step0.ContextImpl.startService</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ComponentName <span class="title function_">startService</span><span class="params">(Intent service)</span> &#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">return</span> startServiceCommon(service, mUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用当前类中的startServiceCommon方法。</p>
<h4 id="Step1-ContextImpl-startServiceCommon"><a href="#Step1-ContextImpl-startServiceCommon" class="headerlink" title="Step1.ContextImpl.startServiceCommon"></a>Step1.ContextImpl.startServiceCommon</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ComponentName <span class="title function_">startServiceCommon</span><span class="params">(Intent service, UserHandle user)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 检验Intent，组件和包名不能为空</span></span><br><span class="line">        validateServiceIntent(service);</span><br><span class="line">        service.prepareToLeaveProcess(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 通过getDefault方法获取AMS的一个代理对象（ActivityManagerProxy），然后调用这个代理对象</span></span><br><span class="line">        <span class="comment">// 的startService方法来请求AMS启动Service</span></span><br><span class="line">        <span class="type">ComponentName</span> <span class="variable">cn</span> <span class="operator">=</span> ActivityManagerNative.getDefault().startService(</span><br><span class="line">                mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</span><br><span class="line">                        getContentResolver()), getOpPackageName(), user.getIdentifier());</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> cn;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先验证Intent中传递的组件名是否为空，为什么判断下面我们介绍，接着通过代理对象ActivityManagerProxy，通过Binder调用AMS（ActivityManagerService）中的对应方法startService。我们先看包名验证。</p>
<h4 id="Step2-ContextImpl-validateServiceIntent"><a href="#Step2-ContextImpl-validateServiceIntent" class="headerlink" title="Step2.ContextImpl.validateServiceIntent"></a>Step2.ContextImpl.validateServiceIntent</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">validateServiceIntent</span><span class="params">(Intent service)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (service.getComponent() == <span class="literal">null</span> &amp;&amp; service.getPackage() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">            <span class="type">IllegalArgumentException</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;Service Intent must be explicit: &quot;</span> + service);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;Implicit intents with startService are not safe: &quot;</span> + service</span><br><span class="line">                    + <span class="string">&quot; &quot;</span> + Debug.getCallers(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里给出了如果系统在Android5.0及以上版本，启动服务必须为显式启动，否则抛出异常，这个情况我们在刚开始在高于5.0系统都会遇到过，限制就在这里，所以，5.0及以上系统必须用显式的方式启动服务。</p>
<h4 id="3-AMP-startService"><a href="#3-AMP-startService" class="headerlink" title="3.AMP.startService"></a>3.AMP.startService</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ComponentName <span class="title function_">startService</span><span class="params">(IApplicationThread caller, Intent service,</span></span><br><span class="line"><span class="params">                                  String resolvedType, String callingPackage, <span class="type">int</span> userId)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 通过Binder对象mRemote向AMS发送一个类型为START_SERVICE_TRANSACTION的进程间通信请求，</span></span><br><span class="line">    <span class="comment">// 然后会调用AMS中的对应的startService方法</span></span><br><span class="line">    mRemote.transact(START_SERVICE_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看过前面文章的对这一段代码应该很熟悉了，这个就是通过Binder调用AMS中对应方法的。所以我们直接看AMS。</p>
<h4 id="4-AMS-startService"><a href="#4-AMS-startService" class="headerlink" title="4.AMS.startService"></a>4.AMS.startService</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ComponentName <span class="title function_">startService</span><span class="params">(IApplicationThread caller, Intent service,</span></span><br><span class="line"><span class="params">                                  String resolvedType, String callingPackage, <span class="type">int</span> userId)</span></span><br><span class="line">        <span class="keyword">throws</span> TransactionTooLargeException &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">ComponentName</span> <span class="variable">res</span> <span class="operator">=</span> mServices.startServiceLocked(caller, service,</span><br><span class="line">                resolvedType, callingPid, callingUid, callingPackage, userId);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的mServices是ActiveServices，因此调用的是ActiveServices中的startServiceLocked方法。</p>
<h4 id="5-ActiveServices-startServiceLocked"><a href="#5-ActiveServices-startServiceLocked" class="headerlink" title="5.ActiveServices.startServiceLocked"></a>5.ActiveServices.startServiceLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">ComponentName <span class="title function_">startServiceLocked</span><span class="params">(IApplicationThread caller, Intent service, String resolvedType,</span></span><br><span class="line"><span class="params">                                 <span class="type">int</span> callingPid, <span class="type">int</span> callingUid, String callingPackage, <span class="keyword">final</span> <span class="type">int</span> userId)</span></span><br><span class="line">        <span class="keyword">throws</span> TransactionTooLargeException &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析service这个Intent，就是解析在AndroidManifest.xml定义的Service标签的intent-filter相关内容</span></span><br><span class="line">    <span class="comment">// 并将其内容保存在Service的record（ServiceRecord）中</span></span><br><span class="line">    <span class="type">ServiceLookupResult</span> <span class="variable">res</span> <span class="operator">=</span></span><br><span class="line">            retrieveServiceLocked(service, resolvedType, callingPackage,</span><br><span class="line">                    callingPid, callingUid, userId, <span class="literal">true</span>, callerFg, <span class="literal">false</span>);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每一个Service组件都使用一个ServiceRecord对象来描述，就像每一个Activity都是用一个ActivityRecord</span></span><br><span class="line">    <span class="comment">// 对象来描述一样</span></span><br><span class="line">    <span class="type">ServiceRecord</span> <span class="variable">r</span> <span class="operator">=</span> res.record;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 加入启动服务列表</span></span><br><span class="line">    r.pendingStarts.add(<span class="keyword">new</span> <span class="title class_">ServiceRecord</span>.StartItem(r, <span class="literal">false</span>, r.makeNextStartId(),</span><br><span class="line">            service, neededGrants));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ServiceMap</span> <span class="variable">smap</span> <span class="operator">=</span> getServiceMap(r.userId);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">addToStarting</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 如果是非前台（后台）进程调用</span></span><br><span class="line">    <span class="keyword">if</span> (!callerFg &amp;&amp; r.app == <span class="literal">null</span></span><br><span class="line">            &amp;&amp; mAm.mUserController.hasStartedUserState(r.userId)) &#123;</span><br><span class="line">        <span class="comment">// 获取启动服务所在进程</span></span><br><span class="line">        <span class="type">ProcessRecord</span> <span class="variable">proc</span> <span class="operator">=</span> mAm.getProcessRecordLocked(r.processName, r.appInfo.uid, <span class="literal">false</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> startServiceInnerLocked(smap, service, r, callerFg, addToStarting);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里做的主要是启动服务前的准备工作，首先是解析Intent携带的参数，并将这些内容保存在用来描述Service的ServiceRecord对象中保存起来，并将该对象放到等待启动服务的列表中。然后调用startServiceInnerLocked启动服务。在上面调用retrieveServiceLocked函数解析的过程中先去判断AMS中是否存在参数为service对应的ServiceRecord对象，如果存在说明已经启动过该服务，如果不存在，说明是第一次启动该服务。</p>
<h4 id="8-ActiveServices-startServiceInnerLocked"><a href="#8-ActiveServices-startServiceInnerLocked" class="headerlink" title="8.ActiveServices.startServiceInnerLocked"></a>8.ActiveServices.startServiceInnerLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ComponentName <span class="title function_">startServiceInnerLocked</span><span class="params">(ServiceMap smap, Intent service, ServiceRecord r,</span></span><br><span class="line"><span class="params">                                       <span class="type">boolean</span> callerFg, <span class="type">boolean</span> addToStarting)</span> <span class="keyword">throws</span> TransactionTooLargeException &#123;</span><br><span class="line">     <span class="type">ServiceState</span> <span class="variable">stracker</span> <span class="operator">=</span> r.getTracker();<span class="comment">// 获取服务状态</span></span><br><span class="line">     ...</span><br><span class="line">     r.callStart = <span class="literal">false</span>;<span class="comment">// 是否调用onStart方法</span></span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 启动ServiceRecord对象r所描述的一个Service组件，即Server组件</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">error</span> <span class="operator">=</span> bringUpServiceLocked(r, service.getFlags(), callerFg, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> r.name;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这里比较简单主要是调用bringUpServiceLocked唤起服务。</p>
<h4 id="Step9-ActiveServices-bringUpServiceLocked"><a href="#Step9-ActiveServices-bringUpServiceLocked" class="headerlink" title="Step9.ActiveServices.bringUpServiceLocked"></a>Step9.ActiveServices.bringUpServiceLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">bringUpServiceLocked</span><span class="params">(ServiceRecord r, <span class="type">int</span> intentFlags, <span class="type">boolean</span> execInFg,</span></span><br><span class="line"><span class="params">                                    <span class="type">boolean</span> whileRestarting, <span class="type">boolean</span> permissionsReviewRequired)</span></span><br><span class="line">        <span class="keyword">throws</span> TransactionTooLargeException &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 这里的r.app.thread是一个ApplicationThread对象，ApplicationThread是用来AMS和应用进程通信的工具，</span></span><br><span class="line">    <span class="comment">// 如果服务中的这个thread不为空说明已经和该Service存在通信了，也就是说已经启动了该服务了。</span></span><br><span class="line">    <span class="comment">// 如果服务已经存在，调用startService的时候会执行Service.onStartCommand，</span></span><br><span class="line">    <span class="comment">// 只有首次启动服务才会调用onCreate方法</span></span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="literal">null</span> &amp;&amp; r.app.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 执行Service.onStartCommand方法过程</span></span><br><span class="line">        sendServiceArgsLocked(r, execInFg, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure that the user who owns this service is started.  If not,</span></span><br><span class="line">    <span class="comment">// we don&#x27;t want to allow it to run.</span></span><br><span class="line">    <span class="comment">// 确保正在启动服务的用户已经启动，否则不允许执行</span></span><br><span class="line">    <span class="keyword">if</span> (!mAm.mUserController.hasStartedUserState(r.userId)) &#123;</span><br><span class="line">        ...</span><br><span class="line">        bringDownServiceLocked(r);</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是不是独立进程</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">isolated</span> <span class="operator">=</span> (r.serviceInfo.flags &amp; ServiceInfo.FLAG_ISOLATED_PROCESS) != <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 首先获取ServiceRecord对象r所描述的Service组件的android:process属性，并保存在procName中</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">procName</span> <span class="operator">=</span> r.processName;</span><br><span class="line">    ProcessRecord app;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isolated) &#123;<span class="comment">// 要启动的服务不是独立进程</span></span><br><span class="line">        <span class="comment">// 如果不是独立进程，通过进程名称和uid查找是否已经存在一个对应的ProcessRecord对象app，如果存在，</span></span><br><span class="line">        <span class="comment">// 说明用来运行这个Service组件的应用进程已经存在了，因此下面的realStartServiceLocked函数在</span></span><br><span class="line">        <span class="comment">// ProcessRecord对象app所描述的应用程序进程中启动这个Service组件。</span></span><br><span class="line">        app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (app != <span class="literal">null</span> &amp;&amp; app.thread != <span class="literal">null</span>) &#123;<span class="comment">// 进程存在，并且该进程已经与AMS通信过，那么直接启动服务</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">// 启动服务</span></span><br><span class="line">                realStartServiceLocked(r, app, execInFg);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If a dead object exception was thrown -- fall through to</span></span><br><span class="line">            <span class="comment">// restart the application.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果要启动的进程是独立进程</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果要启动的Service所在进程没有启动</span></span><br><span class="line">    <span class="keyword">if</span> (app == <span class="literal">null</span> &amp;&amp; !permissionsReviewRequired) &#123;</span><br><span class="line">        <span class="comment">// 启动Service所需要的进程</span></span><br><span class="line">        <span class="keyword">if</span> ((app = mAm.startProcessLocked(procName, r.appInfo, <span class="literal">true</span>, intentFlags,</span><br><span class="line">                <span class="string">&quot;service&quot;</span>, r.name, <span class="literal">false</span>, isolated, <span class="literal">false</span>)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 启动失败</span></span><br><span class="line">            bringDownServiceLocked(r);</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.delayedStop) &#123;<span class="comment">// 如果是延迟停止的服务</span></span><br><span class="line">        <span class="comment">// Oh and hey we&#x27;ve already been asked to stop!</span></span><br><span class="line">        r.delayedStop = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r.startRequested) &#123;</span><br><span class="line">            <span class="comment">// 停止服务</span></span><br><span class="line">            stopServiceLocked(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是启动服务最重要的部分，根据不同的情况进行不同的处理。首先是判断服务所在进程是否存在，如果存在调用sendServiceArgsLocked方法，最终根据条件，如果服务存在调用服务的onStartCommand方法；然后判断被启动服务的用户是否已经被启动，如果没有则停止服务，也就是调用bringDownServiceLocked方法，最终调用服务的onDestroy方法；然后判断非独立进程的服务，如果进程存在并且服务未启动的开始正式启动服务，调用realStartServiceLocked方法，最终调用onCreate方法；然后判断如果进程不存在，要启动进程，并且在app启动后启动服务，这里会调用启动失败，停止启动，因为进程启动后会启动该服务，这个过程在前面我们讲过，这里不再分析这种情况。最后是如果是延迟停止的服务这里直接停止该服务。下面我们按顺序分析这几种情况。</p>
<h4 id="Step10-ActiveServices-sendServiceArgsLocked"><a href="#Step10-ActiveServices-sendServiceArgsLocked" class="headerlink" title="Step10.ActiveServices.sendServiceArgsLocked"></a>Step10.ActiveServices.sendServiceArgsLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">sendServiceArgsLocked</span><span class="params">(ServiceRecord r, <span class="type">boolean</span> execInFg,</span></span><br><span class="line"><span class="params">                                         <span class="type">boolean</span> oomAdjusted)</span> <span class="keyword">throws</span> TransactionTooLargeException &#123;</span><br><span class="line">    <span class="comment">// 等待启动服务个数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> r.pendingStarts.size();</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (r.pendingStarts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ..</span><br><span class="line">            <span class="comment">// 标记启动服务开始</span></span><br><span class="line">            bumpServiceExecutingLocked(r, execInFg, <span class="string">&quot;start&quot;</span>);</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 发送消息，传动到ApplicationThread中的scheduleServiceArgs方法，最终会调用onStartCommand</span></span><br><span class="line">            r.app.thread.scheduleServiceArgs(r, si.taskRemoved, si.id, flags, si.intent);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面Step5提到启动的服务都要先放到等待启动服务列表中，因此这里先判断服务列表是否存在要启动的服务，如果不存在则不再继续执行，如果存在，循环启动服务，这里调用scheduleServiceArgs方法，其实在前面分析了很多遍，最终会发送消息ActivityThread中的Handler中的handleMessage中进行处理，然后调用ActivityThread中的handleServiceArgs方法。</p>
<h4 id="Step13-ActivityThread-handleServiceArgs"><a href="#Step13-ActivityThread-handleServiceArgs" class="headerlink" title="Step13.ActivityThread.handleServiceArgs"></a>Step13.ActivityThread.handleServiceArgs</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleServiceArgs</span><span class="params">(ServiceArgsData data)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取Service对象</span></span><br><span class="line">    <span class="type">Service</span> <span class="variable">s</span> <span class="operator">=</span> mServices.get(data.token);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (!data.taskRemoved) &#123;<span class="comment">// 任务没有被移除的话，调用Service.onStartCommand方法</span></span><br><span class="line">                res = s.onStartCommand(data.args, data.flags, data.startId);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 否则调用被移除方法</span></span><br><span class="line">                s.onTaskRemoved(data.args);</span><br><span class="line">                res = Service.START_TASK_REMOVED_COMPLETE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据Service对应的token去缓存中获取服务，如果有该服务那么调用服务的onStartCommand方法，如果不存在那么就要继续往下走创建服务。</p>
<h4 id="Step15-ActiveServices-bringDownServiceLocked"><a href="#Step15-ActiveServices-bringDownServiceLocked" class="headerlink" title="Step15.ActiveServices.bringDownServiceLocked"></a>Step15.ActiveServices.bringDownServiceLocked</h4><p>这个方法主要是处理停止服务的方法，里面主要是断开连接，解除绑定，然后销毁服务，因为这个过程是在服务停止时会调用，所以在后面介绍，这里先不介绍了。</p>
<h4 id="Step16-ActiveServices-realStartServiceLocked"><a href="#Step16-ActiveServices-realStartServiceLocked" class="headerlink" title="Step16.ActiveServices.realStartServiceLocked"></a>Step16.ActiveServices.realStartServiceLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">realStartServiceLocked</span><span class="params">(ServiceRecord r,</span></span><br><span class="line"><span class="params">                                          ProcessRecord app, <span class="type">boolean</span> execInFg)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">// 发送信息到主线程，准备调用Service.onCreate方法</span></span><br><span class="line">        <span class="comment">// 请求ProcessRecord对象app描述的应用程序进程将ServiceRecord独享r所描述的Service组件启动起来。</span></span><br><span class="line">        <span class="comment">// ServiceRecord对象r所描述的Service组件启动完成之后，AMS就需要将它连接到一个请求绑定它的一个</span></span><br><span class="line">        <span class="comment">// Activity组件中，这是通过调用AMS类的另一个成员函数requestServiceBindingLocked来实现的</span></span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                app.repProcState);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备调用Service.onBind方法</span></span><br><span class="line">    requestServiceBindingsLocked(r, execInFg);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备调用Service.onStartCommand方法</span></span><br><span class="line">    sendServiceArgsLocked(r, execInFg, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动服务调用三个方法，首先是通过app.thread.scheduleCreateService方法调用onCreate方法，然后通过requestServiceBindingsLocked方法调用Service.onBind方法，然后通过sendServiceArgsLocked方法调用Service.onStartCommand方法，其中最后一个方法我们分析过了，所以我们只分析前两个。第一很简单了，最终调用ActivityThread中的handleCreateService方法。</p>
<h4 id="Step18-ActivityThread-handleCreateService"><a href="#Step18-ActivityThread-handleCreateService" class="headerlink" title="Step18.ActivityThread.handleCreateService"></a>Step18.ActivityThread.handleCreateService</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleCreateService</span><span class="params">(CreateServiceData data)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个用来描述即将要启动的Service组件所在的应用程序的LoadedApk对象，并将它保存在packageInfo</span></span><br><span class="line">    <span class="comment">// 变量中（每一个应用程序都使用一个LoadedApk对象来描述，通过它就能方位到它所描述的应用程序的资源）</span></span><br><span class="line">    <span class="type">LoadedApk</span> <span class="variable">packageInfo</span> <span class="operator">=</span> getPackageInfoNoCheck(</span><br><span class="line">            data.info.applicationInfo, data.compatInfo);</span><br><span class="line">    <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">// 获取类加载器</span></span><br><span class="line">        java.lang.<span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> packageInfo.getClassLoader();</span><br><span class="line">        <span class="comment">// 通过类加载器将CreateServiceData对象data描述的一个Service组件加载的内存中，并且创建它的一个</span></span><br><span class="line">        <span class="comment">// 实例，保存在Service对象service中。因为CreateServiceData对象data描述的Service组件即为应用</span></span><br><span class="line">        <span class="comment">// 程序的Ashmem中的Server组件，因此，Service对象service指向的Service组件实际上是一个Server组件</span></span><br><span class="line">        service = (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">// 初始化一个ContextImpl对象context，用来为前面所创建的Service对象service的运行上下文环境，</span></span><br><span class="line">        <span class="comment">// 通过它可以访问特定的应用程序资源，以及启动其他应用程序组件</span></span><br><span class="line">        <span class="type">ContextImpl</span> <span class="variable">context</span> <span class="operator">=</span> ContextImpl.createAppContext(<span class="built_in">this</span>, packageInfo);</span><br><span class="line">        context.setOuterContext(service);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个Application对象app，用来描述Service对象service所属的应用程序。</span></span><br><span class="line">        <span class="type">Application</span> <span class="variable">app</span> <span class="operator">=</span> packageInfo.makeApplication(<span class="literal">false</span>, mInstrumentation);</span><br><span class="line">        <span class="comment">// 使用Application对象app，ContextImpl对象context和CreateServiceData对象data来初始化</span></span><br><span class="line">        <span class="comment">// Service对象service</span></span><br><span class="line">        service.attach(context, <span class="built_in">this</span>, data.info.name, data.token, app,</span><br><span class="line">                ActivityManagerNative.getDefault());</span><br><span class="line">        <span class="comment">// 调用Service的onCreate方法</span></span><br><span class="line">        service.onCreate();</span><br><span class="line">        <span class="comment">// 以token为关键字保存Service对象service到mServices中，服务启动完成</span></span><br><span class="line">        mServices.put(data.token, service);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先获取LoadedApk对象，然后通过类加载器加载Service类，初始化Context，获取对应的Application，如果存在直接返回，如果该应用还没启动则直接创建该Application，然后通过Service的attach方法将对应的信息放置到Service中，这里面就包含ActivityThread，因此我们在Step9中可以通过这个来判断Service是不是被启动了，然后调用onCreate方法，创建完成后，将该服务以token为键，Service为值放入到缓存中，这样我们前面获取的时候就只从这里获取的，因此如果服务启动了换粗就会存在，否则不存在。下面我们分析onBind方法。</p>
<h4 id="Step20-ActiveServices-requestServiceBindingsLocked"><a href="#Step20-ActiveServices-requestServiceBindingsLocked" class="headerlink" title="Step20.ActiveServices.requestServiceBindingsLocked"></a>Step20.ActiveServices.requestServiceBindingsLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数r指向一个ServiceRecord，表示一个已经启动的Service组件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">requestServiceBindingsLocked</span><span class="params">(ServiceRecord r, <span class="type">boolean</span> execInFg)</span></span><br><span class="line">        <span class="keyword">throws</span> TransactionTooLargeException &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> r.bindings.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 每一个IntentBindRecord对象都用来描述若干个需要将ServiceRecord对象r所描述的Service组件</span></span><br><span class="line">        <span class="comment">// 绑定到它们里面的应用程序进程</span></span><br><span class="line">        <span class="type">IntentBindRecord</span> <span class="variable">ibr</span> <span class="operator">=</span> r.bindings.valueAt(i);</span><br><span class="line">        <span class="keyword">if</span> (!requestServiceBindingLocked(r, ibr, execInFg, <span class="literal">false</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for循环调用onBind。</p>
<h4 id="Step21-ActiveServices-requestServiceBindingLocked"><a href="#Step21-ActiveServices-requestServiceBindingLocked" class="headerlink" title="Step21.ActiveServices.requestServiceBindingLocked"></a>Step21.ActiveServices.requestServiceBindingLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数rebind表示是否需要将ServiceRecord对象r所描述的Service组件重新绑定到IntentBindRecord对象i</span></span><br><span class="line"><span class="comment">// 所描述的应用程序进程中如果为false，则说明为第一绑定</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">requestServiceBindingLocked</span><span class="params">(ServiceRecord r, IntentBindRecord i,</span></span><br><span class="line"><span class="params">                                                  <span class="type">boolean</span> execInFg, <span class="type">boolean</span> rebind)</span> <span class="keyword">throws</span> TransactionTooLargeException &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 检查AMS是否已经为IntentBindRecord对象i所描述的应用程序进程请求过ServiceRecord对象r所描述的</span></span><br><span class="line">    <span class="comment">// Service组件返回其内部的一个Binder本地对象。如果还没有请求requested为false并且apps的数量大于0</span></span><br><span class="line">    <span class="keyword">if</span> ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//会执行到Service的onBind方法</span></span><br><span class="line">            r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</span><br><span class="line">                    r.app.repProcState);</span><br><span class="line">            <span class="keyword">if</span> (!rebind) &#123;</span><br><span class="line">                <span class="comment">// 设置为true，防止重复请求</span></span><br><span class="line">                i.requested = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里通过调用r.app.thread.scheduleBindService方法，最终调用到ActivityThread中的handleBindService方法。</p>
<h4 id="Step23-ActivityThread-handleBindService"><a href="#Step23-ActivityThread-handleBindService" class="headerlink" title="Step23.ActivityThread.handleBindService"></a>Step23.ActivityThread.handleBindService</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleBindService</span><span class="params">(BindServiceData data)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过token来获得一个描述Service组件的Service对象</span></span><br><span class="line">    <span class="type">Service</span> <span class="variable">s</span> <span class="operator">=</span> mServices.get(data.token);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           ...</span><br><span class="line">                <span class="keyword">if</span> (!data.rebind) &#123;<span class="comment">// 首次绑定</span></span><br><span class="line">                    <span class="comment">// 获取一个实现了IBinder接口的Binder对象</span></span><br><span class="line">                    <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> s.onBind(data.intent);</span><br><span class="line">                    ...</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    s.onRebind(data.intent);</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现获取服务，然后判断是再次绑定还是首次绑定，如果是首次绑定调用Service.onBind方法，如果是再次绑定调用Service.onRebind方法。到这里服务的启动就完成了，其他一些操作就不分析了。下面我们先分析另外一个启动流程bindService，最后分析停止服务流程。</p>
<h2 id="Service启动流程-bindService"><a href="#Service启动流程-bindService" class="headerlink" title="Service启动流程-bindService"></a>Service启动流程-bindService</h2><p>首先来看绑定流程时序图：</p>
<p><img src="/images/AndroidOS/008Service/Service3.jpg" alt="Service启动时序图"></p>
<h4 id="Step1-ContextImpl-bindService"><a href="#Step1-ContextImpl-bindService" class="headerlink" title="Step1.ContextImpl.bindService"></a>Step1.ContextImpl.bindService</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">bindService</span><span class="params">(Intent service, ServiceConnection conn,</span></span><br><span class="line"><span class="params">                           <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">return</span> bindServiceCommon(service, conn, flags, mMainThread.getHandler(),</span><br><span class="line">            Process.myUserHandle());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是绑定服务的入口位置，调用bindServiceCommon方法。</p>
<h4 id="Step2-ContextImpl-bindServiceCommon"><a href="#Step2-ContextImpl-bindServiceCommon" class="headerlink" title="Step2.ContextImpl.bindServiceCommon"></a>Step2.ContextImpl.bindServiceCommon</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">bindServiceCommon</span><span class="params">(Intent service, ServiceConnection conn, <span class="type">int</span> flags, Handler</span></span><br><span class="line"><span class="params">        handler, UserHandle user)</span> &#123;</span><br><span class="line">    IServiceConnection sd;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// mPackageInfo类型是LoadedApk</span></span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将ServiceConnection对象conn封装成一个实现了IServiceConnection接口的Binder本地对象sd</span></span><br><span class="line">        sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">IBinder</span> <span class="variable">token</span> <span class="operator">=</span> getActivityToken();</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 通过调用代理对象ActivityManagerProxy的bindService方法将前面获得的sd对象，以及Intent对象</span></span><br><span class="line">        <span class="comment">// service等信息发送给AMS，以便AMS可以将ServiceConnection组件启动起来</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> ActivityManagerNative.getDefault().bindService(</span><br><span class="line">                mMainThread.getApplicationThread(), getActivityToken(), service,</span><br><span class="line">                service.resolveTypeIfNeeded(getContentResolver()),</span><br><span class="line">                sd, flags, getOpPackageName(), user.getIdentifier());</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> res != <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先调用LoadedApk中的getServiceDispatcher方法获取实现IServiceConnection接口的Binder对象ServiceDispatcher.InnerConnection。然后调用AMP中的bindService方法，然后通过Binder通信调用AMS中的bindService方法。</p>
<h4 id="Step3-LoadedApk-getServiceDispatcher"><a href="#Step3-LoadedApk-getServiceDispatcher" class="headerlink" title="Step3.LoadedApk.getServiceDispatcher"></a>Step3.LoadedApk.getServiceDispatcher</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每一个绑定过Service组件的Activity组件在LoadedApk类中都有一个对应的ServiceDispatcher对象，它负责将</span></span><br><span class="line"><span class="comment">// 这个被绑定的Service组件与绑定它的Activity组件关联起来，这些ServiceDispatcher保存在map中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> IServiceConnection <span class="title function_">getServiceDispatcher</span><span class="params">(ServiceConnection c,</span></span><br><span class="line"><span class="params">                                                     Context context, Handler handler, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mServices) &#123;</span><br><span class="line">        LoadedApk.<span class="type">ServiceDispatcher</span> <span class="variable">sd</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map = mServices.get(context);</span><br><span class="line">        <span class="comment">// 检查成员变量mServices中是否存在一个以ServiceConnection对象c为关键字的ServiceDispatcher</span></span><br><span class="line">        <span class="comment">// 对象sd，如果不存在，则创建一个并且以context为关键字保存到mServices中</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">            sd = map.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sd == <span class="literal">null</span>) &#123;</span><br><span class="line">            sd = <span class="keyword">new</span> <span class="title class_">ServiceDispatcher</span>(c, context, handler, flags);</span><br><span class="line">            <span class="keyword">if</span> (map == <span class="literal">null</span>) &#123;</span><br><span class="line">                map = <span class="keyword">new</span> <span class="title class_">ArrayMap</span>&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;();</span><br><span class="line">                mServices.put(context, map);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(c, sd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sd.validate(context, handler);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用前面获取到的ServiceDispatcher对象sd的成员函数getIServiceConnection来获取一个实现了</span></span><br><span class="line">        <span class="comment">// IServiceConnection接口的本地Binder对象</span></span><br><span class="line">        <span class="keyword">return</span> sd.getIServiceConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先根据ServiceConnection取缓存中获取，如果没有要初始化一个ServiceDispatcher对象，然后获取ServiceDispatcher.InnerConnection对象并且返回。</p>
<h4 id="Step6-AMP-bindService"><a href="#Step6-AMP-bindService" class="headerlink" title="Step6.AMP.bindService"></a>Step6.AMP.bindService</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bindService</span><span class="params">(IApplicationThread caller, IBinder token,</span></span><br><span class="line"><span class="params">                       Intent service, String resolvedType, IServiceConnection connection,</span></span><br><span class="line"><span class="params">                       <span class="type">int</span> flags, String callingPackage, <span class="type">int</span> userId)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 通过Binder对象mRemote向AMS发送一个类型为BIND_SERVICE_TRANSACTION的进程间通信请求</span></span><br><span class="line">    mRemote.transact(BIND_SERVICE_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里通过Binder调用AMS中对应的方法。</p>
<h4 id="Step7-AMS-bindService"><a href="#Step7-AMS-bindService" class="headerlink" title="Step7.AMS.bindService"></a>Step7.AMS.bindService</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bindService</span><span class="params">(IApplicationThread caller, IBinder token, Intent service,</span></span><br><span class="line"><span class="params">                       String resolvedType, IServiceConnection connection, <span class="type">int</span> flags, String callingPackage,</span></span><br><span class="line"><span class="params">                       <span class="type">int</span> userId)</span> <span class="keyword">throws</span> TransactionTooLargeException &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mServices.bindServiceLocked(caller, token, service,</span><br><span class="line">                resolvedType, connection, flags, callingPackage, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用ActiveServices.bindServiceLocked方法。</p>
<h4 id="Step8-ActiveServices-bindServiceLocked"><a href="#Step8-ActiveServices-bindServiceLocked" class="headerlink" title="Step8.ActiveServices.bindServiceLocked"></a>Step8.ActiveServices.bindServiceLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bindServiceLocked</span><span class="params">(IApplicationThread caller, IBinder token, Intent service,</span></span><br><span class="line"><span class="params">                      String resolvedType, <span class="keyword">final</span> IServiceConnection connection, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                      String callingPackage, <span class="keyword">final</span> <span class="type">int</span> userId)</span> <span class="keyword">throws</span> TransactionTooLargeException &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">&quot;bindService: &quot;</span> + service</span><br><span class="line">            + <span class="string">&quot; type=&quot;</span> + resolvedType + <span class="string">&quot; conn=&quot;</span> + connection.asBinder()</span><br><span class="line">            + <span class="string">&quot; flags=0x&quot;</span> + Integer.toHexString(flags));</span><br><span class="line">    <span class="comment">// 根据caller来获取一个ProcessRecord对象callerApp用来描述AMS执行绑定Service组件操作的一个Activity</span></span><br><span class="line">    <span class="comment">// 组件所运行在的应用程序进程</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ProcessRecord</span> <span class="variable">callerApp</span> <span class="operator">=</span> mAm.getRecordForAppLocked(caller);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="type">ActivityRecord</span> <span class="variable">activity</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (token != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过token来获得一个ActivityRecord对象activity，用来描述正在请求AMS执行绑定Service组件</span></span><br><span class="line">        <span class="comment">// 操作的一个Activity组件</span></span><br><span class="line">        activity = ActivityRecord.isInStackLocked(token);</span><br><span class="line">        <span class="keyword">if</span> (activity == <span class="literal">null</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Binding with unknown activity: &quot;</span> + token);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">callerFg</span> <span class="operator">=</span> callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">    <span class="comment">// 是否是绑定了外部服务，这个服务不是应用中的服务，而是外部独立的服务（我们通常启动服务都是应用内部的服务）</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">isBindExternal</span> <span class="operator">=</span> (flags &amp; Context.BIND_EXTERNAL_SERVICE) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据参数service来得到一个ServiceRecord对象s，用来描述即将被绑定的Service组件</span></span><br><span class="line">    <span class="type">ServiceLookupResult</span> <span class="variable">res</span> <span class="operator">=</span></span><br><span class="line">            retrieveServiceLocked(service, resolvedType, callingPackage, Binder.getCallingPid(),</span><br><span class="line">                    Binder.getCallingUid(), userId, <span class="literal">true</span>, callerFg, isBindExternal);</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">// 调用ServiceRecord对象s的成员函数retrieveAppBindingLocked来得到一个AppBindRecord对象b，</span></span><br><span class="line">        <span class="comment">// 表示ServiceRecord对象s所描述的Service组件是绑定在ProcessRecord对象callerApp所描述的一个</span></span><br><span class="line">        <span class="comment">// 应用程序进程中的</span></span><br><span class="line">        <span class="type">AppBindRecord</span> <span class="variable">b</span> <span class="operator">=</span> s.retrieveAppBindingLocked(service, callerApp);</span><br><span class="line">        <span class="comment">// 将前面获得的APPBindRecord对象、ActivityRecord对象Activity以及参数connection封装成一个</span></span><br><span class="line">        <span class="comment">// ConnectionRecord对象s所描述的一个Service组件，并且这个Activity组件是运行在</span></span><br><span class="line">        <span class="comment">// ProcessRecord对象callerApp所描述的一个应用进程中的</span></span><br><span class="line">        <span class="type">ConnectionRecord</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionRecord</span>(b, activity,</span><br><span class="line">                connection, flags, clientLabel, clientIntent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于一个Service组件可能会被同一个应用程序进程中的多个Activity组件使用同一个InnerConnection</span></span><br><span class="line">        <span class="comment">// 对象来绑定，因此，在AMS中，用来描述该Service组件的ServiceRecord对象就有可能会对应有多个</span></span><br><span class="line">        <span class="comment">// ConnectionRecord对象。在这种情况下，这些ConnectionRecord对象就会被保存在一个列表中。</span></span><br><span class="line">        <span class="comment">// 这个列表最终会保存在对应的ServiceRecord对象的成员变量Connection所描述的HashMap中，并且以</span></span><br><span class="line">        <span class="comment">// 它里面的ConnectionRecord对象共同使用的一个InnerConnection代理对象的IBinder接口为关键字</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数connection是一个InnerConnection代理对象，因此可以获取它的一个IBinder接口binder</span></span><br><span class="line">        <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> connection.asBinder();</span><br><span class="line">        <span class="comment">// 检测在ServiceRecord对象s中是否存在一个以IBinder接口binder为关键字的列表clist，如果不存在</span></span><br><span class="line">        <span class="comment">// 创建一个，并且将clist以binder为关键字放到ServiceRecord对象成员变量connections中</span></span><br><span class="line">        ArrayList&lt;ConnectionRecord&gt; clist = s.connections.get(binder);</span><br><span class="line">        <span class="keyword">if</span> (clist == <span class="literal">null</span>) &#123;<span class="comment">// 没有绑定过</span></span><br><span class="line">            clist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ConnectionRecord&gt;();</span><br><span class="line">            s.connections.put(binder, clist);</span><br><span class="line">        &#125;</span><br><span class="line">        clist.add(c);<span class="comment">// 添加绑定列表</span></span><br><span class="line">        b.connections.add(c);<span class="comment">// 添加到关联应用和服务的对象AppBindRecord中记录绑定列表中</span></span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (activity.connections == <span class="literal">null</span>) &#123;<span class="comment">// 这里判断Activity里面是否绑定过服务</span></span><br><span class="line">                activity.connections = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;ConnectionRecord&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加到描述Activity的ActivityRecord对象中记录绑定服务的列表中</span></span><br><span class="line">            activity.connections.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 从记录该服务所有绑定列表中获取是否存在绑定列表</span></span><br><span class="line">        clist = mServiceConnections.get(binder);</span><br><span class="line">        <span class="keyword">if</span> (clist == <span class="literal">null</span>) &#123;</span><br><span class="line">            clist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ConnectionRecord&gt;();</span><br><span class="line">            mServiceConnections.put(binder, clist);</span><br><span class="line">        &#125;</span><br><span class="line">        clist.add(c);<span class="comment">// 添加都所有列表中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从前面可知flags的Context.BIND_AUTO_CREATE位等于1，因此会调用bringUpServiceLocked来启动</span></span><br><span class="line">        <span class="comment">// ServiceRecord对象s所描述的一个Service组件，等到这个Service组件启动以后，AMS再将它与</span></span><br><span class="line">        <span class="comment">// ActivityRecord对象Activity所描述的一个Activity绑定自来</span></span><br><span class="line">        <span class="keyword">if</span> ((flags &amp; Context.BIND_AUTO_CREATE) != <span class="number">0</span>) &#123;</span><br><span class="line">            s.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (bringUpServiceLocked(s, service.getFlags(), callerFg, <span class="literal">false</span>,</span><br><span class="line">                    permissionsReviewRequired) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="literal">null</span> &amp;&amp; b.intent.received) &#123;</span><br><span class="line">            <span class="comment">// Service is already running, so we can immediately</span></span><br><span class="line">            <span class="comment">// publish the connection.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 这里的c.conn是ServiceDispatcher.InnerConnection对象，这里最终调用</span></span><br><span class="line">                <span class="comment">// ServiceDispatcher中的doConnected方法</span></span><br><span class="line">                c.conn.connected(s.name, b.intent.binder);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">&quot;Failure sending service &quot;</span> + s.shortName</span><br><span class="line">                        + <span class="string">&quot; to connection &quot;</span> + c.conn.asBinder()</span><br><span class="line">                        + <span class="string">&quot; (in &quot;</span> + c.binding.client.processName + <span class="string">&quot;)&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If this is the first app connected back to this binding,</span></span><br><span class="line">            <span class="comment">// and the service had previously asked to be told when</span></span><br><span class="line">            <span class="comment">// rebound, then do so.</span></span><br><span class="line">            <span class="keyword">if</span> (b.intent.apps.size() == <span class="number">1</span> &amp;&amp; b.intent.doRebind) &#123;<span class="comment">// 重新绑定</span></span><br><span class="line">                requestServiceBindingLocked(s, b.intent, callerFg, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!b.intent.requested) &#123;<span class="comment">// 首次绑定</span></span><br><span class="line">            requestServiceBindingLocked(s, b.intent, callerFg, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        getServiceMap(s.userId).ensureNotStartingBackground(s);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里代码比较多，所以写的注释也比较多，前面主要是判断是否绑定过该服务，并对InnerConnection进行缓存，放置到各个列表中，让Activity，Service进行联系。最后调用requestServiceBindingLocked方法，这个方法调用两次，一次是首次绑定，一个是重新绑定。</p>
<h4 id="Step9-AMS-requestServiceBindingLocked"><a href="#Step9-AMS-requestServiceBindingLocked" class="headerlink" title="Step9.AMS.requestServiceBindingLocked"></a>Step9.AMS.requestServiceBindingLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数rebind表示是否需要将ServiceRecord对象r所描述的Service组件重新绑定到IntentBindRecord对象i</span></span><br><span class="line"><span class="comment">// 所描述的应用程序进程中如果为false，则说明为第一绑定</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">requestServiceBindingLocked</span><span class="params">(ServiceRecord r, IntentBindRecord i,</span></span><br><span class="line"><span class="params">                                                  <span class="type">boolean</span> execInFg, <span class="type">boolean</span> rebind)</span> <span class="keyword">throws</span> TransactionTooLargeException &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 检查AMS是否已经为IntentBindRecord对象i所描述的应用程序进程请求过ServiceRecord对象r所描述的</span></span><br><span class="line">    <span class="comment">// Service组件返回其内部的一个Binder本地对象。如果还没有请求requested为false并且apps的数量大于0</span></span><br><span class="line">    <span class="keyword">if</span> ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bumpServiceExecutingLocked(r, execInFg, <span class="string">&quot;bind&quot;</span>);</span><br><span class="line">            r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">            <span class="comment">// 会执行到Service的onBind方法</span></span><br><span class="line">            r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</span><br><span class="line">                    r.app.repProcState);</span><br><span class="line">            <span class="keyword">if</span> (!rebind) &#123;</span><br><span class="line">                <span class="comment">// 设置为true，防止重复请求</span></span><br><span class="line">                i.requested = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i.hasBound = <span class="literal">true</span>;</span><br><span class="line">            i.doRebind = <span class="literal">false</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是判断首次绑定还是重新绑定，这两种绑定都会执行绑定步骤，这里有个参数i.requested，代表是否是首次绑定，如果默认值是false，如果不是重新绑定，那么执行完绑定就会设置为true。然后调用thread.scheduleBindServic方法，这个方法讲了很多次了，最终调用ApplicationThread.scheduleBindService方法，然后通过handler调用ActivityThread.handleBindService方法。</p>
<h4 id="Step10-ActivityThread-handleBindService"><a href="#Step10-ActivityThread-handleBindService" class="headerlink" title="Step10.ActivityThread.handleBindService"></a>Step10.ActivityThread.handleBindService</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleBindService</span><span class="params">(BindServiceData data)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过token来获得一个描述Service组件的Service对象</span></span><br><span class="line">    <span class="type">Service</span> <span class="variable">s</span> <span class="operator">=</span> mServices.get(data.token);</span><br><span class="line">    ...</span><br><span class="line">                <span class="keyword">if</span> (!data.rebind) &#123;<span class="comment">// 首次绑定</span></span><br><span class="line">                    <span class="comment">// 获取一个实现了IBinder接口的Binder对象</span></span><br><span class="line">                    <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> s.onBind(data.intent);</span><br><span class="line">                    <span class="comment">// 调用AMS代理对象的成员函数publishService，将前面得到的Binder本地对象传递给AMS</span></span><br><span class="line">                    ActivityManagerNative.getDefault().publishService(</span><br><span class="line">                            data.token, data.intent, binder);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    s.onRebind(data.intent);</span><br><span class="line">                    ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                            data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里如果是首次绑定调用onBind方法，否则调用onRebind方法，在首次调用绑定后还有publishService方法，自己看一下，不在详细分析了。这样绑定流程就分析完了，难度不大。下面我们开分析解绑过程。</p>
<h2 id="Service解绑流程-unbindService"><a href="#Service解绑流程-unbindService" class="headerlink" title="Service解绑流程-unbindService"></a>Service解绑流程-unbindService</h2><p>首先来看解绑流程时序图：</p>
<p><img src="/images/AndroidOS/008Service/Service4.jpg" alt="Service解绑时序图"></p>
<h4 id="Step1-ContextImpl-unbindService"><a href="#Step1-ContextImpl-unbindService" class="headerlink" title="Step1.ContextImpl.unbindService"></a>Step1.ContextImpl.unbindService</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unbindService</span><span class="params">(ServiceConnection conn)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取将ServiceConnection对象conn封装成一个实现了IServiceConnection接口的Binder</span></span><br><span class="line">        <span class="comment">// 本地对象sd（ServiceDispatcher.InnerConnection）</span></span><br><span class="line">        <span class="type">IServiceConnection</span> <span class="variable">sd</span> <span class="operator">=</span> mPackageInfo.forgetServiceDispatcher(</span><br><span class="line">                getOuterContext(), conn);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ActivityManagerNative.getDefault().unbindService(sd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Not supported in system context&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IServiceConnection对象的获取我们前面分析过了，这里直接过，然后调用AMP.unbindService方法，最终调用AMS.unbindService方法。</p>
<h4 id="Step3-AMS-unbindService"><a href="#Step3-AMS-unbindService" class="headerlink" title="Step3.AMS.unbindService"></a>Step3.AMS.unbindService</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">unbindService</span><span class="params">(IServiceConnection connection)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mServices.unbindServiceLocked(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用ActiveServices.unbindServiceLocked方法。</p>
<h4 id="Step4-ActiveServices-unbindServiceLocked"><a href="#Step4-ActiveServices-unbindServiceLocked" class="headerlink" title="Step4.ActiveServices.unbindServiceLocked"></a>Step4.ActiveServices.unbindServiceLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">unbindServiceLocked</span><span class="params">(IServiceConnection connection)</span> &#123;</span><br><span class="line">    <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> connection.asBinder();</span><br><span class="line">    <span class="comment">// 获取缓存中绑定列表</span></span><br><span class="line">    ArrayList&lt;ConnectionRecord&gt; clist = mServiceConnections.get(binder);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (clist.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">ConnectionRecord</span> <span class="variable">r</span> <span class="operator">=</span> clist.get(<span class="number">0</span>);</span><br><span class="line">            removeConnectionLocked(r, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (clist.size() &gt; <span class="number">0</span> &amp;&amp; clist.get(<span class="number">0</span>) == r) &#123;</span><br><span class="line">                <span class="comment">// In case it didn&#x27;t get removed above, do it now.</span></span><br><span class="line">                Slog.wtf(TAG, <span class="string">&quot;Connection &quot;</span> + r + <span class="string">&quot; not removed for binder &quot;</span> + binder);</span><br><span class="line">                clist.remove(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先从AMS中获取绑定过的列表，如果存在说明绑定过，然后调用removeConnectionLocked移除连接。</p>
<h4 id="Step5-ActiveServices-removeConnectionLocked"><a href="#Step5-ActiveServices-removeConnectionLocked" class="headerlink" title="Step5.ActiveServices.removeConnectionLocked"></a>Step5.ActiveServices.removeConnectionLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">removeConnectionLocked</span><span class="params">(</span></span><br><span class="line"><span class="params">        ConnectionRecord c, ProcessRecord skipApp, ActivityRecord skipAct)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取连接中的Binder对象</span></span><br><span class="line">    <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> c.conn.asBinder();</span><br><span class="line">    <span class="comment">// 获取连接应用、服务和连接列表的客户端</span></span><br><span class="line">    <span class="type">AppBindRecord</span> <span class="variable">b</span> <span class="operator">=</span> c.binding;</span><br><span class="line">    <span class="comment">// 获取描述服务的对象</span></span><br><span class="line">    <span class="type">ServiceRecord</span> <span class="variable">s</span> <span class="operator">=</span> b.service;</span><br><span class="line">    <span class="comment">// 根据Binder对象获取服务绑定的连接列表</span></span><br><span class="line">    ArrayList&lt;ConnectionRecord&gt; clist = s.connections.get(binder);</span><br><span class="line">    <span class="keyword">if</span> (clist != <span class="literal">null</span>) &#123;</span><br><span class="line">        clist.remove(c);<span class="comment">// 移除该连接对象</span></span><br><span class="line">        <span class="keyword">if</span> (clist.size() == <span class="number">0</span>) &#123;<span class="comment">// 如果列表为空，移除该列表</span></span><br><span class="line">            s.connections.remove(binder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从连接应用、服务和连接列表的客户端中的连接列表中移除</span></span><br><span class="line">    b.connections.remove(c);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 从总的缓存列表中移除</span></span><br><span class="line">    clist = mServiceConnections.get(binder);</span><br><span class="line">    <span class="keyword">if</span> (clist != <span class="literal">null</span>) &#123;</span><br><span class="line">        clist.remove(c);</span><br><span class="line">        <span class="keyword">if</span> (clist.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            mServiceConnections.remove(binder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mAm.stopAssociationLocked(b.client.uid, b.client.processName, s.appInfo.uid, s.name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果连接应用、服务和连接列表的客户端中的连接列表为空了，说明没有绑定了，那么移除该客户端</span></span><br><span class="line">    <span class="keyword">if</span> (b.connections.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        b.intent.apps.remove(b.client);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!c.serviceDead) &#123;<span class="comment">// 服务还存在</span></span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="literal">null</span> &amp;&amp; s.app.thread != <span class="literal">null</span> &amp;&amp; b.intent.apps.size() == <span class="number">0</span></span><br><span class="line">                &amp;&amp; b.intent.hasBound) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">                b.intent.doRebind = <span class="literal">false</span>;</span><br><span class="line">                s.app.thread.scheduleUnbindService(s, b.intent.intent.getIntent());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">&quot;Exception when unbinding service &quot;</span> + s.shortName, e);</span><br><span class="line">                serviceProcessGoneLocked(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在绑定服务的时候进行各种缓存，加入各种列表，那么在接触绑定的时候就有从之前加入的列表中删除，然后执行接触绑定。</p>
<h4 id="Step7-ActivityThread-handleUnbindService"><a href="#Step7-ActivityThread-handleUnbindService" class="headerlink" title="Step7.ActivityThread.handleUnbindService"></a>Step7.ActivityThread.handleUnbindService</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleUnbindService</span><span class="params">(BindServiceData data)</span> &#123;</span><br><span class="line">    <span class="type">Service</span> <span class="variable">s</span> <span class="operator">=</span> mServices.get(data.token);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">doRebind</span> <span class="operator">=</span> s.onUnbind(data.intent);<span class="comment">// 调用解绑回调</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用Service的onUnbind接触绑定。到这里接触绑定就分析完了，过程比较简单，只是上面的各种列表搞清楚要多看看。最后就剩下了stopService，我们一口气就将它分析完。</p>
<h2 id="Service停止流程-stopService"><a href="#Service停止流程-stopService" class="headerlink" title="Service停止流程-stopService"></a>Service停止流程-stopService</h2><p>首先来看停止服务流程时序图：</p>
<p><img src="/images/AndroidOS/008Service/Service2.jpg" alt="Service停止时序图"></p>
<h4 id="Step1-ContextImpl-stopSevice"><a href="#Step1-ContextImpl-stopSevice" class="headerlink" title="Step1.ContextImpl.stopSevice"></a>Step1.ContextImpl.stopSevice</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 停止服务</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">stopService</span><span class="params">(Intent service)</span> &#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">return</span> stopServiceCommon(service, mUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用stopServiceCommon停止服务。</p>
<h4 id="Step2-ContextImpl-stopServiceCommon"><a href="#Step2-ContextImpl-stopServiceCommon" class="headerlink" title="Step2.ContextImpl.stopServiceCommon"></a>Step2.ContextImpl.stopServiceCommon</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">stopServiceCommon</span><span class="params">(Intent service, UserHandle user)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 检验Intent，组件和包名不能为空</span></span><br><span class="line">        validateServiceIntent(service);</span><br><span class="line">        service.prepareToLeaveProcess(<span class="built_in">this</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> ActivityManagerNative.getDefault().stopService(</span><br><span class="line">                mMainThread.getApplicationThread(), service,</span><br><span class="line">                service.resolveTypeIfNeeded(getContentResolver()), user.getIdentifier());</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> res != <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里最终调用AMS的stopService方法。</p>
<h4 id="Step3-AMS-stopService"><a href="#Step3-AMS-stopService" class="headerlink" title="Step3.AMS.stopService"></a>Step3.AMS.stopService</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">stopService</span><span class="params">(IApplicationThread caller, Intent service,</span></span><br><span class="line"><span class="params">                       String resolvedType, <span class="type">int</span> userId)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mServices.stopServiceLocked(caller, service, resolvedType, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是简单的调用ActiveServices.stopServiceLocked方法。</p>
<h4 id="Step4-ActiveServices-stopServiceLocked"><a href="#Step4-ActiveServices-stopServiceLocked" class="headerlink" title="Step4.ActiveServices.stopServiceLocked"></a>Step4.ActiveServices.stopServiceLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">stopServiceLocked</span><span class="params">(IApplicationThread caller, Intent service,</span></span><br><span class="line"><span class="params">                      String resolvedType, <span class="type">int</span> userId)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据caller获取调用者进程</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ProcessRecord</span> <span class="variable">callerApp</span> <span class="operator">=</span> mAm.getRecordForAppLocked(caller);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">                stopServiceLocked(r.record);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单的调用了stopServiceLocked方法。</p>
<h4 id="Step6-ActiveServices-stopServiceLocked"><a href="#Step6-ActiveServices-stopServiceLocked" class="headerlink" title="Step6.ActiveServices.stopServiceLocked"></a>Step6.ActiveServices.stopServiceLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">stopServiceLocked</span><span class="params">(ServiceRecord service)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    bringDownServiceIfNeededLocked(service, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们前面分析过bringUp的是启动服务，因此对应的bringDown的是结束服务。</p>
<h4 id="Step7-ActiveServices-bringDownServiceIfNeededLocked"><a href="#Step7-ActiveServices-bringDownServiceIfNeededLocked" class="headerlink" title="Step7.ActiveServices.bringDownServiceIfNeededLocked"></a>Step7.ActiveServices.bringDownServiceIfNeededLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 停止服务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">bringDownServiceIfNeededLocked</span><span class="params">(ServiceRecord r, <span class="type">boolean</span> knowConn,</span></span><br><span class="line"><span class="params">                                                  <span class="type">boolean</span> hasConn)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    bringDownServiceLocked(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只是简单的调用了bringDownServiceLocked方法，这个方法我们在服务启动时也遇到过，只是没有分析，我们放到了停止服务的流程中来分析，下面我们看看详细代码。</p>
<h4 id="Step8-ActiveServices-bringDownServiceLocked"><a href="#Step8-ActiveServices-bringDownServiceLocked" class="headerlink" title="Step8.ActiveServices.bringDownServiceLocked"></a>Step8.ActiveServices.bringDownServiceLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">bringDownServiceLocked</span><span class="params">(ServiceRecord r)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">conni</span> <span class="operator">=</span> r.connections.size() - <span class="number">1</span>; conni &gt;= <span class="number">0</span>; conni--) &#123;</span><br><span class="line">        ArrayList&lt;ConnectionRecord&gt; c = r.connections.valueAt(conni);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; c.size(); i++) &#123;</span><br><span class="line">            ...</span><br><span class="line">                <span class="comment">// 断开服务连接</span></span><br><span class="line">                cr.conn.connected(r.name, <span class="literal">null</span>);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell the service that it has been unbound.</span></span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="literal">null</span> &amp;&amp; r.app.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> r.bindings.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">IntentBindRecord</span> <span class="variable">ibr</span> <span class="operator">=</span> r.bindings.valueAt(i);</span><br><span class="line">            <span class="keyword">if</span> (ibr.hasBound) &#123;<span class="comment">// 所有服务与客户端已经解绑</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="comment">// 调用Service的onUnbind方法</span></span><br><span class="line">                    r.app.thread.scheduleUnbindService(r,</span><br><span class="line">                            ibr.intent.getIntent());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="literal">null</span>) &#123;<span class="comment">// 服务进程存在</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (r.app.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">            updateServiceForegroundLocked(r.app, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">// 停止服务，调用onDestroy方法</span></span><br><span class="line">                r.app.thread.scheduleStopService(r);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要有三步，第一步，断开服务连接，这个方法我们前面提到过，可以根据前面提到的去看看如何断开连接的；第二步，如果已经绑定了服务要解除绑定，这个在上面解除绑定的时候分析了该过程，因此这里就不再重复了；第三步，如果服务存在，则停止服务。我们开始分析第三步，第三步这里最终调用ActivityThread的handleStopService方法。</p>
<h4 id="Step13-ActivityThread-handleStopService"><a href="#Step13-ActivityThread-handleStopService" class="headerlink" title="Step13.ActivityThread.handleStopService"></a>Step13.ActivityThread.handleStopService</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleStopService</span><span class="params">(IBinder token)</span> &#123;</span><br><span class="line">    <span class="type">Service</span> <span class="variable">s</span> <span class="operator">=</span> mServices.remove(token);</span><br><span class="line">    ...</span><br><span class="line">            s.onDestroy();</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里如果服务存在则调用服务的onDestroy方法，到这里服务的停止也就结束了。从上面看服务的整个流程相对于Activity简单的多。很容易就看懂了。其实还有一个IntentService，整个服务继承Service，只不过里面多了一个Handler，我们看看这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ServiceHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceHandler</span><span class="params">(Looper looper)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        onHandleIntent((Intent)msg.obj);</span><br><span class="line">        stopSelf(msg.arg1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有Handler就有发送消息的地方，那么发送消息在哪里呢，我们知道当你调用服务的时候会走onStartCommand方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">onStartCommand</span><span class="params">(<span class="meta">@Nullable</span> Intent intent, <span class="type">int</span> flags, <span class="type">int</span> startId)</span> &#123;</span><br><span class="line">    onStart(intent, startId);</span><br><span class="line">    <span class="keyword">return</span> mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会调用onStart方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(<span class="meta">@Nullable</span> Intent intent, <span class="type">int</span> startId)</span> &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mServiceHandler.obtainMessage();</span><br><span class="line">    msg.arg1 = startId;</span><br><span class="line">    msg.obj = intent;</span><br><span class="line">    mServiceHandler.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是发送消息的时候，消息发出后会由上面的ServiceHandler来处理，我们看到构造函数里传入了一个Looper，这个是在onCreate方法中初始化的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> It would be nice to have an option to hold a partial wakelock</span></span><br><span class="line">    <span class="comment">// during processing, and to have a static startService(Context, Intent)</span></span><br><span class="line">    <span class="comment">// method that would launch the service &amp; hand off a wakelock.</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">super</span>.onCreate();</span><br><span class="line">    <span class="type">HandlerThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerThread</span>(<span class="string">&quot;IntentService[&quot;</span> + mName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    mServiceLooper = thread.getLooper();</span><br><span class="line">    mServiceHandler = <span class="keyword">new</span> <span class="title class_">ServiceHandler</span>(mServiceLooper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里创建了一个Handler线程，并且获取了它的Looper，用来循环处理消息，因此我们知道同时只能处理一个消息，等前一个消息处理完了才会处理第二个，以此类推，因此需要同时处理的不能用这个Service，另外在ServiceHandler中有个stopSelf用来在消息处理完成后停止自己，因此该服务可以说是用完自动停止，不会一直存在，占用资源。</p>
<h2 id="代码地址："><a href="#代码地址：" class="headerlink" title="代码地址："></a>代码地址：</h2><p>直接拉取导入开发工具（Intellij idea或者Android studio）</p>
<p><a target="_blank" rel="noopener" href="https://github.com/yuchuangu85/Android_Framework_Source">Android_Framework_Source</a></p>
<h2 id="注"><a href="#注" class="headerlink" title="注"></a>注</h2><p>Android开发群：192508518</p>
<p>微信公众账号：Code-MX<br><img width="240" src="/images/codemx/qr_code_mx.jpg"/></p>
<p>注：本文原创，转载请注明出处，多谢。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://www.codemx.cn">墨香</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://www.codemx.cn/2018/04/24/AndroidOS010-Service/">http://www.codemx.cn/2018/04/24/AndroidOS010-Service/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.codemx.cn" target="_blank">墨香博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/AndroidOS/">AndroidOS</a></div><div class="post-share"><div class="social-share" data-image="/img/head.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="prev-post pull-left" href="/2018/07/13/AndroidOS011-ContentProvider/" title="Android系统源码分析--ContentProvider"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android系统源码分析--ContentProvider</div></div></a><a class="next-post pull-right" href="/2018/03/12/AndroidOS009-Activity/" title="Android系统源码分析--Activity的finish过程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android系统源码分析--Activity的finish过程</div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a href="/2017/06/03/AndroidOS001/" title="IntelliJ IDEA导入Android源码"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-06-03</div><div class="title">IntelliJ IDEA导入Android源码</div></div></a><a href="/2017/06/05/AndroidOS002-Context/" title="Android系统源码分析--Context"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-06-05</div><div class="title">Android系统源码分析--Context</div></div></a><a href="/2017/07/12/AndroidOS003-SystemServer/" title="Android系统源码分析--Zygote和SystemServer启动过程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-07-12</div><div class="title">Android系统源码分析--Zygote和SystemServer启动过程</div></div></a><a href="/2017/07/13/AndroidOS004-HandleMessageLooper/" title="Android系统源码分析--消息循环机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-07-13</div><div class="title">Android系统源码分析--消息循环机制</div></div></a><a href="/2017/09/13/AndroidOS005-Process/" title="Android系统源码分析--Process启动过程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-09-13</div><div class="title">Android系统源码分析--Process启动过程</div></div></a><a href="/2017/12/21/AndroidOS006-Broadcast1/" title="Android系统源码分析--Broadcast注册和注销"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-12-21</div><div class="title">Android系统源码分析--Broadcast注册和注销</div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">墨香</div><div class="author-info-description">因为兴趣所以选择，因为选择所以坚持。</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yuchuangu85"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/yuchuangu85" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:yuchuangu85@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">路虽远，行则将至；事虽难，做则可成。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Service%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-startService"><span class="toc-number">1.</span> <span class="toc-text">Service启动流程-startService</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Step0-ContextImpl-startService"><span class="toc-number">1.0.1.</span> <span class="toc-text">Step0.ContextImpl.startService</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step1-ContextImpl-startServiceCommon"><span class="toc-number">1.0.2.</span> <span class="toc-text">Step1.ContextImpl.startServiceCommon</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step2-ContextImpl-validateServiceIntent"><span class="toc-number">1.0.3.</span> <span class="toc-text">Step2.ContextImpl.validateServiceIntent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-AMP-startService"><span class="toc-number">1.0.4.</span> <span class="toc-text">3.AMP.startService</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-AMS-startService"><span class="toc-number">1.0.5.</span> <span class="toc-text">4.AMS.startService</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-ActiveServices-startServiceLocked"><span class="toc-number">1.0.6.</span> <span class="toc-text">5.ActiveServices.startServiceLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-ActiveServices-startServiceInnerLocked"><span class="toc-number">1.0.7.</span> <span class="toc-text">8.ActiveServices.startServiceInnerLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step9-ActiveServices-bringUpServiceLocked"><span class="toc-number">1.0.8.</span> <span class="toc-text">Step9.ActiveServices.bringUpServiceLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step10-ActiveServices-sendServiceArgsLocked"><span class="toc-number">1.0.9.</span> <span class="toc-text">Step10.ActiveServices.sendServiceArgsLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step13-ActivityThread-handleServiceArgs"><span class="toc-number">1.0.10.</span> <span class="toc-text">Step13.ActivityThread.handleServiceArgs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step15-ActiveServices-bringDownServiceLocked"><span class="toc-number">1.0.11.</span> <span class="toc-text">Step15.ActiveServices.bringDownServiceLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step16-ActiveServices-realStartServiceLocked"><span class="toc-number">1.0.12.</span> <span class="toc-text">Step16.ActiveServices.realStartServiceLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step18-ActivityThread-handleCreateService"><span class="toc-number">1.0.13.</span> <span class="toc-text">Step18.ActivityThread.handleCreateService</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step20-ActiveServices-requestServiceBindingsLocked"><span class="toc-number">1.0.14.</span> <span class="toc-text">Step20.ActiveServices.requestServiceBindingsLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step21-ActiveServices-requestServiceBindingLocked"><span class="toc-number">1.0.15.</span> <span class="toc-text">Step21.ActiveServices.requestServiceBindingLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step23-ActivityThread-handleBindService"><span class="toc-number">1.0.16.</span> <span class="toc-text">Step23.ActivityThread.handleBindService</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Service%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B-bindService"><span class="toc-number">2.</span> <span class="toc-text">Service启动流程-bindService</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Step1-ContextImpl-bindService"><span class="toc-number">2.0.1.</span> <span class="toc-text">Step1.ContextImpl.bindService</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step2-ContextImpl-bindServiceCommon"><span class="toc-number">2.0.2.</span> <span class="toc-text">Step2.ContextImpl.bindServiceCommon</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step3-LoadedApk-getServiceDispatcher"><span class="toc-number">2.0.3.</span> <span class="toc-text">Step3.LoadedApk.getServiceDispatcher</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step6-AMP-bindService"><span class="toc-number">2.0.4.</span> <span class="toc-text">Step6.AMP.bindService</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step7-AMS-bindService"><span class="toc-number">2.0.5.</span> <span class="toc-text">Step7.AMS.bindService</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step8-ActiveServices-bindServiceLocked"><span class="toc-number">2.0.6.</span> <span class="toc-text">Step8.ActiveServices.bindServiceLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step9-AMS-requestServiceBindingLocked"><span class="toc-number">2.0.7.</span> <span class="toc-text">Step9.AMS.requestServiceBindingLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step10-ActivityThread-handleBindService"><span class="toc-number">2.0.8.</span> <span class="toc-text">Step10.ActivityThread.handleBindService</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Service%E8%A7%A3%E7%BB%91%E6%B5%81%E7%A8%8B-unbindService"><span class="toc-number">3.</span> <span class="toc-text">Service解绑流程-unbindService</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Step1-ContextImpl-unbindService"><span class="toc-number">3.0.1.</span> <span class="toc-text">Step1.ContextImpl.unbindService</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step3-AMS-unbindService"><span class="toc-number">3.0.2.</span> <span class="toc-text">Step3.AMS.unbindService</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step4-ActiveServices-unbindServiceLocked"><span class="toc-number">3.0.3.</span> <span class="toc-text">Step4.ActiveServices.unbindServiceLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step5-ActiveServices-removeConnectionLocked"><span class="toc-number">3.0.4.</span> <span class="toc-text">Step5.ActiveServices.removeConnectionLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step7-ActivityThread-handleUnbindService"><span class="toc-number">3.0.5.</span> <span class="toc-text">Step7.ActivityThread.handleUnbindService</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Service%E5%81%9C%E6%AD%A2%E6%B5%81%E7%A8%8B-stopService"><span class="toc-number">4.</span> <span class="toc-text">Service停止流程-stopService</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Step1-ContextImpl-stopSevice"><span class="toc-number">4.0.1.</span> <span class="toc-text">Step1.ContextImpl.stopSevice</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step2-ContextImpl-stopServiceCommon"><span class="toc-number">4.0.2.</span> <span class="toc-text">Step2.ContextImpl.stopServiceCommon</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step3-AMS-stopService"><span class="toc-number">4.0.3.</span> <span class="toc-text">Step3.AMS.stopService</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step4-ActiveServices-stopServiceLocked"><span class="toc-number">4.0.4.</span> <span class="toc-text">Step4.ActiveServices.stopServiceLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step6-ActiveServices-stopServiceLocked"><span class="toc-number">4.0.5.</span> <span class="toc-text">Step6.ActiveServices.stopServiceLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step7-ActiveServices-bringDownServiceIfNeededLocked"><span class="toc-number">4.0.6.</span> <span class="toc-text">Step7.ActiveServices.bringDownServiceIfNeededLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step8-ActiveServices-bringDownServiceLocked"><span class="toc-number">4.0.7.</span> <span class="toc-text">Step8.ActiveServices.bringDownServiceLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step13-ActivityThread-handleStopService"><span class="toc-number">4.0.8.</span> <span class="toc-text">Step13.ActivityThread.handleStopService</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9C%B0%E5%9D%80%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">代码地址：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8"><span class="toc-number">6.</span> <span class="toc-text">注</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/04/ANR06/" title="ANR-实例分析-Input dispatching timed out">ANR-实例分析-Input dispatching timed out</a><time datetime="2024-11-04T14:17:38.000Z" title="发表于 2024-11-04 22:17:38">2024-11-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/28/ANR05/" title="ANR-实例分析-启动应用失败">ANR-实例分析-启动应用失败</a><time datetime="2024-10-28T14:04:48.000Z" title="发表于 2024-10-28 22:04:48">2024-10-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/21/ANR04/" title="ANR-分析之基础知识介绍：logcat">ANR-分析之基础知识介绍：logcat</a><time datetime="2024-10-21T14:19:03.000Z" title="发表于 2024-10-21 22:19:03">2024-10-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/25/Google-Jetpack-Compose-Animation/" title="Google-Jetpack-Compose-Animation">Google-Jetpack-Compose-Animation</a><time datetime="2024-08-24T16:54:13.000Z" title="发表于 2024-08-25 00:54:13">2024-08-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/24/ANR03/" title="ANR-分析之基础知识介绍：event log">ANR-分析之基础知识介绍：event log</a><time datetime="2024-08-24T15:41:04.000Z" title="发表于 2024-08-24 23:41:04">2024-08-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2016 - 2024 By 墨香</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>