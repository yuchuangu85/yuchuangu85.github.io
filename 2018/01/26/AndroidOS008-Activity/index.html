<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Android系统源码分析--Activity启动过程 | 墨香博客</title><meta name="author" content="墨香"><meta name="copyright" content="墨香"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="关于Activity的源码分析拖延了太久的时间，由于最近工作繁忙，加上Activity启动源码非常复杂，涉及的内容很多，所以花费了很长是时间才来写这篇源码分析，希望这篇分析能让我们很容易的理解Activity的启动流程，能解决我们在使用Activity过程中遇到的问题，这样就达到了我们对于源码分析的目的了。下一篇我们介绍Activity的finish过程。">
<meta property="og:type" content="article">
<meta property="og:title" content="Android系统源码分析--Activity启动过程">
<meta property="og:url" content="http://www.codemx.cn/2018/01/26/AndroidOS008-Activity/index.html">
<meta property="og:site_name" content="墨香博客">
<meta property="og:description" content="关于Activity的源码分析拖延了太久的时间，由于最近工作繁忙，加上Activity启动源码非常复杂，涉及的内容很多，所以花费了很长是时间才来写这篇源码分析，希望这篇分析能让我们很容易的理解Activity的启动流程，能解决我们在使用Activity过程中遇到的问题，这样就达到了我们对于源码分析的目的了。下一篇我们介绍Activity的finish过程。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.codemx.cn/img/head.jpg">
<meta property="article:published_time" content="2018-01-26T03:40:33.000Z">
<meta property="article:modified_time" content="2024-07-12T16:41:32.275Z">
<meta property="article:author" content="墨香">
<meta property="article:tag" content="AndroidOS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.codemx.cn/img/head.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.codemx.cn/2018/01/26/AndroidOS008-Activity/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>(()=>{
      const saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
      
      window.btf = {
        saveToLocal: saveToLocal,
        getScript: (url, attr = {}) => new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = url
          script.async = true
          script.onerror = reject
          script.onload = script.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            script.onload = script.onreadystatechange = null
            resolve()
          }

          Object.keys(attr).forEach(key => {
            script.setAttribute(key, attr[key])
          })

          document.head.appendChild(script)
        }),

        getCSS: (url, id = false) => new Promise((resolve, reject) => {
          const link = document.createElement('link')
          link.rel = 'stylesheet'
          link.href = url
          if (id) link.id = id
          link.onerror = reject
          link.onload = link.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            link.onload = link.onreadystatechange = null
            resolve()
          }
          document.head.appendChild(link)
        }),

        addGlobalFn: (key, fn, name = false, parent = window) => {
          const pjaxEnable = false
          if (!pjaxEnable && key.startsWith('pjax')) return

          const globalFn = parent.globalFn || {}
          const keyObj = globalFn[key] || {}
    
          if (name && keyObj[name]) return
    
          name = name || Object.keys(keyObj).length
          keyObj[name] = fn
          globalFn[key] = keyObj
          parent.globalFn = globalFn
        }
      }
    
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode
      
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Android系统源码分析--Activity启动过程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-13 00:41:32'
}</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg" style="background-image: url(/img/bg.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img fixed" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="墨香博客"><span class="site-name">墨香博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Android系统源码分析--Activity启动过程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2018-01-26T03:40:33.000Z" title="发表于 2018-01-26 11:40:33">2018-01-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-12T16:41:32.275Z" title="更新于 2024-07-13 00:41:32">2024-07-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AndroidOS/">AndroidOS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Android系统源码分析--Activity启动过程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><blockquote>
<p>关于Activity的源码分析拖延了太久的时间，由于最近工作繁忙，加上Activity启动源码非常复杂，涉及的内容很多，所以花费了很长是时间才来写这篇源码分析，希望这篇分析能让我们很容易的理解Activity的启动流程，能解决我们在使用Activity过程中遇到的问题，这样就达到了我们对于源码分析的目的了。下一篇我们介绍Activity的finish过程。</p>
</blockquote>
<span id="more"></span>

<h2 id="Activity启动模式简介："><a href="#Activity启动模式简介：" class="headerlink" title="Activity启动模式简介："></a>Activity启动模式简介：</h2><p>我们知道Activity启动模式有四种，每一种都有不同的操作，直接影响我们App的设计，为了帮助我们理解源码，我们先分析一下这四种模式。这四种模式包括：standard, singleTop, singleTask 和 singleInstance。</p>
<p>（下面内容来自：<a target="_blank" rel="noopener" href="http://jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0520/2897.html">Activity启动模式图文详解：standard, singleTop, singleTask 以及 singleInstance</a>）</p>
<ul>
<li><p><strong>standard</strong>：标准模式，也是默认模式。这种模式是每次你调用startActivity时都会创建一个Activity实例，不管你之前有没有创建过。</p>
</li>
<li><p><strong>singleTop</strong>：从名字可以分析出是顶部单例，也就是如果你要启动的Activity在任务栈的顶部，则不会在创建新的Activity实例，而是调用Activity的onNewIntent方法，如果你要启动的Activity不存在或者存在但是不在任务栈的栈顶，那么也会创建新的Activity实例并且放置到栈顶位置。因此如果你需要处理Intent中的参数，那么需要在onCreate方法和onNewIntent方法中都要处理。</p>
</li>
<li><p><strong>singleTask</strong>：从名字看是单例模式，这个单例不是栈单例，而是系统单例，也就是如果系统中存在了该Activity，那么在调用startActivity时并不会重新创建一个Activity，而是将持有这个Activity的任务移动到顶部位置，并且调用onNewIntent方法，同时在这个栈中的该Activity上面的Activity都会被弹出栈并且被销毁，如果系统中不存在则会创建新的Activity，并且将这个Activity放置到一个新的任务栈中的底部（root）位置。</p>
<p>  但是，同一个应用中，我们正常使用中同一个应用中的Activity启动却不是这样，启动的具有该属性的Activity会被放到栈的顶部，而不是放到root（底部）位置，如果需要像上面描述一样放到root位置，那么需要在AndroidManifest文件中配置Activity时添加<strong>taskAffinity</strong>属性，例如：</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.SingleTaskActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">&quot;singleTask launchMode&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">&quot;singleTask&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:taskAffinity</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  在不同的应用启动Activity，如果两个应用启动具有该属性的Activity就会创建一个新的任务，并且将该Activity放置到该任务的底部位置。除非用该属性的Activity所在的应用已经存在了，新创建该属性Activity后会将其放置到顶部位置。如果在其他的任务中存在了该属性的Activity，整个任务都会被移到顶部位置，并且该Activity上面的所有Activity都会被销毁，用户需要按back键遍历栈中的Activity才能回到调用者。</p>
</li>
<li><p><strong>singleInstance</strong>：单例模式，这个模式和singleTask很相似，不同的是：持有这个Activity的任务只有一个Activity，即这个单例本身。如果这个Activity启动另一个Activity的时候会自动创建一个任务栈，并且将新启动的Activity放到该新创建的任务栈中。不过结果很怪异，当具有该模式的Activity启动另一个Activity或者另一个Activity启动具有该模式的Activity时本来需要创建一个新的任务，但是任务管理中只显示了一个（最后被移到顶部的那个），导致后台只显示一个，我们不能切换到之前的任务中。如果想切换唯一办法就是回到Launcher重新点击应用，但是显示另个一任务后，第一个任务就会被隐藏了。也就是切换后还是只能显示一个任务。如果想要解决仍然需要设置<strong>taskAffinity</strong>属性，例如：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.SingleTaskActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">&quot;singleTask launchMode&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">&quot;singleTask&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:taskAffinity</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>  这样就正常了，这种模式很少使用，除非想Launcher这种只有一个Activity，或者100%确定只有一个Activity。</p>
</li>
</ul>
<h2 id="Activity源码解析"><a href="#Activity源码解析" class="headerlink" title="Activity源码解析"></a>Activity源码解析</h2><p>要了解Activity启动的过程不仅要知道代码流程，也要知道设计流程，我们先看代码流程，分析完成后我们再重新看一下设计流程，来帮助我们记忆源码流程。因为篇幅比较长，我们下面分为两个部分分析。</p>
<h3 id="第一部分："><a href="#第一部分：" class="headerlink" title="第一部分："></a>第一部分：</h3><p><img src="/images/AndroidOS/007Activity/ActivityStart1.jpg" alt="Activity启动时序图"></p>
<h4 id="Step1-startActivityForResult"><a href="#Step1-startActivityForResult" class="headerlink" title="Step1.startActivityForResult:"></a>Step1.startActivityForResult:</h4><p>Activity的启动一般有了两种方式，一种是需要返回结果的，一种是不需要返回结果的。这里的函数和我们上面时序图中的不一样，其实最终调用的方法是这个，另外还有几个参数不同的方法，其实是一样的，我们看最终调用代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startActivityForResult</span><span class="params">(<span class="meta">@RequiresPermission</span> Intent intent, <span class="type">int</span> requestCode,</span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> Bundle options)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mParent == <span class="literal">null</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// Instrumentation是用来监控程序与系统之间的交互操作的，mMainThread的类型为ActivityThread，</span></span><br><span class="line">            <span class="comment">// 是用来描述应用程序进程的，系统每当启动一个应用程序进程时，都会在它里面加载一个ActivityThread</span></span><br><span class="line">            <span class="comment">// 类实体，并且这个类实体会保存在每一个在该进程中启动的Activity组件的父类Activity的成员变量</span></span><br><span class="line">            <span class="comment">// mMainThread中。ActivityThread的成员函数getApplicationThread用来获取它内部一个类型为</span></span><br><span class="line">            <span class="comment">// ApplicationThread对象作为参数传递给变量mInstrumentation的成员函数execStartActivity，</span></span><br><span class="line">            <span class="comment">// 以便将它传递给AMS，这样就可以通过ApplicationThread与Activity交流了。Activity的成员变量</span></span><br><span class="line">            <span class="comment">// mToken的类型为IBinder，它是Binder代理对象，指向AMS中一个类型为ActivityRecord对象，用来维护</span></span><br><span class="line">            <span class="comment">// 对应的Activity组件的运行状态以及信息。此处传入也是为了传递给AMS，这样AMS就可以得到Activity的</span></span><br><span class="line">            <span class="comment">// 详细信息了。</span></span><br><span class="line">            Instrumentation.<span class="type">ActivityResult</span> <span class="variable">ar</span> <span class="operator">=</span></span><br><span class="line">                mInstrumentation.execStartActivity(</span><br><span class="line">                    <span class="built_in">this</span>, mMainThread.getApplicationThread(), mToken, <span class="built_in">this</span>,</span><br><span class="line">                    intent, requestCode, options);</span><br><span class="line">            <span class="keyword">if</span> (ar != <span class="literal">null</span>) &#123;</span><br><span class="line">                mMainThread.sendActivityResult(</span><br><span class="line">                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                    ar.getResultData());</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>直接启动时参数requestCode为-1，这里执行调用Instrumentation.execStartActivity方法，后面执行ActivityThread.sendActivityResult返回结果，这个方法我们后面会分析，这里不再分析，我们先看启动的方法：</p>
<h4 id="Step2-Instrumentation-execStartActivity"><a href="#Step2-Instrumentation-execStartActivity" class="headerlink" title="Step2.Instrumentation.execStartActivity"></a>Step2.Instrumentation.execStartActivity</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ActivityResult <span class="title function_">execStartActivity</span><span class="params">(</span></span><br><span class="line"><span class="params">            Context who, IBinder contextThread, IBinder token, Activity target,</span></span><br><span class="line"><span class="params">            Intent intent, <span class="type">int</span> requestCode, Bundle options)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">            <span class="comment">// 获取AMS的代理对象AMP（ActivityManagerProxy），然后调用起startActivity方法，通过该方法</span></span><br><span class="line">            <span class="comment">// 通知AMS启动Activity</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ActivityManagerNative.getDefault()</span><br><span class="line">                .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                        intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                        token, target != <span class="literal">null</span> ? target.mEmbeddedID : <span class="literal">null</span>,</span><br><span class="line">                        requestCode, <span class="number">0</span>, <span class="literal">null</span>, options);</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法传入有个参数target，从上面代码可知传入的是this，也就是调用启动Activity方法的Activity，我们称之为调用者或者源Activity。这里主要是调用startActivity方法，这里的ActivityManagerNative.getDefault()我们在前面的文字介绍过是ActivityManagerProxy。</p>
<h4 id="Step3-ActivityManagerProxy-startActivity"><a href="#Step3-ActivityManagerProxy-startActivity" class="headerlink" title="Step3.ActivityManagerProxy.startActivity"></a>Step3.ActivityManagerProxy.startActivity</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage, Intent intent,</span></span><br><span class="line"><span class="params">                             String resolvedType, IBinder resultTo, String resultWho, <span class="type">int</span> requestCode,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 通过AMP类内部的一个IBinder代理对象想AMS发送一个类型为START_ACTIVITY_TRANSACTION的进程间通信请求</span></span><br><span class="line">        mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最终调用AMS(ActivityManagerService)的startActivity方法。</p>
<h4 id="Step4-AMS-startActivity"><a href="#Step4-AMS-startActivity" class="headerlink" title="Step4.AMS.startActivity"></a>Step4.AMS.startActivity</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span><br><span class="line"><span class="params">                                   Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="type">int</span> requestCode,</span></span><br><span class="line"><span class="params">                                   <span class="type">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">                resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class="line">                UserHandle.getCallingUserId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后调用startActivityAsUser方法。</p>
<h4 id="Step5-AMS-startActivityAsUser"><a href="#Step5-AMS-startActivityAsUser" class="headerlink" title="Step5.AMS.startActivityAsUser"></a>Step5.AMS.startActivityAsUser</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span><br><span class="line"><span class="params">                                         Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="type">int</span> requestCode,</span></span><br><span class="line"><span class="params">                                         <span class="type">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class="type">int</span> userId)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// mActivityStarter是Activity启动等操作的管理者</span></span><br><span class="line">        <span class="keyword">return</span> mActivityStarter.startActivityMayWait(caller, -<span class="number">1</span>, callingPackage, intent,</span><br><span class="line">                resolvedType, <span class="literal">null</span>, <span class="literal">null</span>, resultTo, resultWho, requestCode, startFlags,</span><br><span class="line">                profilerInfo, <span class="literal">null</span>, <span class="literal">null</span>, bOptions, <span class="literal">false</span>, userId, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>调用ActivityStarter.startActivityMayWait方法。</p>
<h4 id="Step6-ActivityStarter-startActivityMayWait"><a href="#Step6-ActivityStarter-startActivityMayWait" class="headerlink" title="Step6.ActivityStarter.startActivityMayWait"></a>Step6.ActivityStarter.startActivityMayWait</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该函数的Wait表示对于outResult的处理上</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">startActivityMayWait</span><span class="params">(IApplicationThread caller, <span class="type">int</span> callingUid,</span></span><br><span class="line"><span class="params">                                   String callingPackage, Intent intent, String resolvedType,</span></span><br><span class="line"><span class="params">                                   IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span><br><span class="line"><span class="params">                                   IBinder resultTo, String resultWho, <span class="type">int</span> requestCode, <span class="type">int</span> startFlags,</span></span><br><span class="line"><span class="params">                                   ProfilerInfo profilerInfo, IActivityManager.WaitResult outResult, Configuration config,</span></span><br><span class="line"><span class="params">                                   Bundle bOptions, <span class="type">boolean</span> ignoreTargetSecurity, <span class="type">int</span> userId,</span></span><br><span class="line"><span class="params">                                   IActivityContainer iContainer, TaskRecord inTask)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 是否指定了要启动Activity相关的组件名，如果指定了组件名则为显示启动，否则为隐式启动</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">componentSpecified</span> <span class="operator">=</span> intent.getComponent() != <span class="literal">null</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 收集Intent中的信息</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">synchronized</span> (mService) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">final</span> ActivityRecord[] outRecord = <span class="keyword">new</span> <span class="title class_">ActivityRecord</span>[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> startActivityLocked(caller, intent, ephemeralIntent, resolvedType,</span><br><span class="line">                    aInfo, rInfo, voiceSession, voiceInteractor,</span><br><span class="line">                    resultTo, resultWho, requestCode, callingPid,</span><br><span class="line">                    callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,</span><br><span class="line">                    options, ignoreTargetSecurity, componentSpecified, outRecord, container,</span><br><span class="line">                    inTask);</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里主要是收集Intent的内容，进行判断整理，然后调用startActivityLocked方法。</p>
<h4 id="Step7-startActivityLocked"><a href="#Step7-startActivityLocked" class="headerlink" title="Step7.startActivityLocked"></a>Step7.startActivityLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Locked 代表非线程安全的，提醒我们必须保证这些函数是线程安全的，（因为他们涉及不可重入资源的处理）</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">startActivityLocked</span><span class="params">(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span></span><br><span class="line"><span class="params">                              String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span></span><br><span class="line"><span class="params">                              IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span><br><span class="line"><span class="params">                              IBinder resultTo, String resultWho, <span class="type">int</span> requestCode, <span class="type">int</span> callingPid, <span class="type">int</span> callingUid,</span></span><br><span class="line"><span class="params">                              String callingPackage, <span class="type">int</span> realCallingPid, <span class="type">int</span> realCallingUid, <span class="type">int</span> startFlags,</span></span><br><span class="line"><span class="params">                              ActivityOptions options, <span class="type">boolean</span> ignoreTargetSecurity, <span class="type">boolean</span> componentSpecified,</span></span><br><span class="line"><span class="params">                              ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,</span></span><br><span class="line"><span class="params">                              TaskRecord inTask)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">err</span> <span class="operator">=</span> ActivityManager.START_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取调用者进程记录对象，每一个进程都使用一个ProcessRecord对象来描述，并且会保存起来</span></span><br><span class="line">    <span class="type">ProcessRecord</span> <span class="variable">callerApp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// mService指向AMS，通过caller来获取对应的ProcessRecord对象callerApp，参数caller指向</span></span><br><span class="line">        <span class="comment">// 启动Activity的组件所运行在的应用程序进程的一个ApplicationThread对象，因此ProcessRecord</span></span><br><span class="line">        <span class="comment">// 对象callerApp指向了启动者所在的应用程序进程（正在启动的为被调用者）。</span></span><br><span class="line">        callerApp = mService.getRecordForAppLocked(caller);</span><br><span class="line">        <span class="keyword">if</span> (callerApp != <span class="literal">null</span>) &#123;<span class="comment">// 调用者进程存在</span></span><br><span class="line">            callingPid = callerApp.pid;</span><br><span class="line">            callingUid = callerApp.info.uid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 调用者被系统杀死或者意外退出</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">ActivityRecord</span> <span class="variable">sourceRecord</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">// 调用者Activity封装</span></span><br><span class="line">    <span class="type">ActivityRecord</span> <span class="variable">resultRecord</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">// 需要接受返回结果的Activity对象封装</span></span><br><span class="line">    <span class="keyword">if</span> (resultTo != <span class="literal">null</span>) &#123;<span class="comment">// 需要返回结果</span></span><br><span class="line">        <span class="comment">// 查找所有栈中是否存在对应resultTo（调用者）的ActivityRecord</span></span><br><span class="line">        sourceRecord = mSupervisor.isInAnyStackLocked(resultTo);</span><br><span class="line">        <span class="keyword">if</span> (sourceRecord != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果requestCode大于等于0（也就是需要返回结果的启动Activity），</span></span><br><span class="line">            <span class="comment">// 并且请求者的Activity没有在等待finish队列中，说明sourceRecord就是接受结果的Activity</span></span><br><span class="line">            <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span> &amp;&amp; !sourceRecord.finishing) &#123;</span><br><span class="line">                <span class="comment">// 将启动者的Activity作为接受结果的Activity</span></span><br><span class="line">                resultRecord = sourceRecord;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">launchFlags</span> <span class="operator">=</span> intent.getFlags();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接启动Activity时requestCode为-1，因此sourceRecord为空，resultRecord为空</span></span><br><span class="line">    <span class="comment">// 这里对标志位Intent.FLAG_ACTIVITY_FORWARD_RESULT进行了判断，我们先解释一下这个标志位：如果A启动了B</span></span><br><span class="line">    <span class="comment">// 并且需要返回结果，而B需要启动了C从C返回结果给A，那么B需要设置Intent.FLAG_ACTIVITY_FORWARD_RESULT标志</span></span><br><span class="line">    <span class="comment">// 位，并且为了避免冲突B在启动C时不需要再设置requestCode，而此时sourceRecord是B，resultRecord是A，</span></span><br><span class="line">    <span class="comment">// 就是下面代码的解释，设置该标志后，C调用setResult时结果不会传递给B而是传递给A。</span></span><br><span class="line">    <span class="keyword">if</span> ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != <span class="number">0</span> &amp;&amp; sourceRecord != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Transfer the result target from the source activity to the new</span></span><br><span class="line">        <span class="comment">// one being started, including any failures.</span></span><br><span class="line">        <span class="comment">// 这里requestCode是B传过来的，如果设置了上面的标签，B就不能再设置requestCode，因此，如果</span></span><br><span class="line">        <span class="comment">// requestCode&gt;=0就会产生冲突，因此B不能再设置requestCode</span></span><br><span class="line">        <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ActivityOptions.abort(options);</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果设置了上面的标签，最终的接受结果的Activity就是B（sourceRecord）中resultTo指向的Activity而不是B</span></span><br><span class="line">        resultRecord = sourceRecord.resultTo;</span><br><span class="line">        <span class="comment">// 如果启动者resultRecord不在栈中，赋值为空</span></span><br><span class="line">        <span class="keyword">if</span> (resultRecord != <span class="literal">null</span> &amp;&amp; !resultRecord.isInStackLocked()) &#123;</span><br><span class="line">            resultRecord = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        requestCode = sourceRecord.requestCode;<span class="comment">// 传递requestCode</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (resultRecord != <span class="literal">null</span>) &#123;<span class="comment">// 还存在栈中，移除结果</span></span><br><span class="line">            resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不需要返回结果直接启动Activity时resultRecord为空</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityStack</span> <span class="variable">resultStack</span> <span class="operator">=</span> resultRecord == <span class="literal">null</span> ? <span class="literal">null</span> : resultRecord.task.stack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != START_SUCCESS) &#123;<span class="comment">// 失败</span></span><br><span class="line">        <span class="keyword">if</span> (resultRecord != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 需要返回结果的启动Activity，调用Activity.onActivityResult，返回操作取消的结果</span></span><br><span class="line">            resultStack.sendActivityResultLocked(</span><br><span class="line">                    -<span class="number">1</span>, resultRecord, resultWho, requestCode, RESULT_CANCELED, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ActivityOptions.abort(options);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (abort) &#123;<span class="comment">// 如果终止</span></span><br><span class="line">        <span class="keyword">if</span> (resultRecord != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 等待返回结果的Activity，调用Activity.onActivityResult方法，返回取消操作的结果</span></span><br><span class="line">            resultStack.sendActivityResultLocked(-<span class="number">1</span>, resultRecord, resultWho, requestCode,</span><br><span class="line">                    RESULT_CANCELED, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ActivityOptions.abort(options);</span><br><span class="line">        <span class="keyword">return</span> START_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个ActivityRecord对象r来描述即将被启动的Activity组件</span></span><br><span class="line">    <span class="type">ActivityRecord</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityRecord</span>(mService, callerApp, callingUid, callingPackage,</span><br><span class="line">            intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho,</span><br><span class="line">            requestCode, componentSpecified, voiceSession != <span class="literal">null</span>, mSupervisor, container,</span><br><span class="line">            options, sourceRecord);</span><br><span class="line">    <span class="keyword">if</span> (outActivity != <span class="literal">null</span>) &#123;</span><br><span class="line">        outActivity[<span class="number">0</span>] = r;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取栈</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityStack</span> <span class="variable">stack</span> <span class="operator">=</span> mSupervisor.mFocusedStack;</span><br><span class="line">    <span class="comment">// 前面voiceSession传入为空，并且没有可恢复的Activity或者可恢复的Activity不是当前调用者</span></span><br><span class="line">    <span class="keyword">if</span> (voiceSession == <span class="literal">null</span> &amp;&amp; (stack.mResumedActivity == <span class="literal">null</span></span><br><span class="line">            || stack.mResumedActivity.info.applicationInfo.uid != callingUid)) &#123;</span><br><span class="line">        <span class="comment">// 前台栈(stack)还没有resume状态的Activity时, 则检查app切换是否允许，不允许切换则要放入等待列表</span></span><br><span class="line">        <span class="keyword">if</span> (!mService.checkAppSwitchAllowedLocked(callingPid, callingUid,</span><br><span class="line">                realCallingPid, realCallingUid, <span class="string">&quot;Activity start&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 不许切换时，获取启动新Activity请求的描述，放到等待列表</span></span><br><span class="line">            <span class="type">PendingActivityLaunch</span> <span class="variable">pal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PendingActivityLaunch</span>(r,</span><br><span class="line">                    sourceRecord, startFlags, stack, callerApp);</span><br><span class="line">            <span class="comment">// 添加PendingActivityLaunch</span></span><br><span class="line">            mPendingActivityLaunches.add(pal);</span><br><span class="line">            ActivityOptions.abort(options);</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.START_SWITCHES_CANCELED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许切换</span></span><br><span class="line">    <span class="keyword">if</span> (mService.mDidAppSwitch) &#123;</span><br><span class="line">        mService.mAppSwitchesAllowedTime = <span class="number">0</span>;<span class="comment">// 将切换时间设置为0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mService.mDidAppSwitch = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理等待启动的Activity</span></span><br><span class="line">    doPendingActivityLaunchesLocked(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 启动目标Activity操作</span></span><br><span class="line">        err = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags,</span><br><span class="line">                <span class="literal">true</span>, options, inTask);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mService.mWindowManager.continueSurfaceLayout();</span><br><span class="line">    &#125;</span><br><span class="line">    postStartActivityUncheckedProcessing(r, err, stack.mStackId, mSourceRecord, mTargetStack);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码注释比较详细，有一点我们提一下就是FLAG_ACTIVITY_FORWARD_RESULT标签，也就是我们在开发中遇到的一种情况，ActivityA启动ActivityB，ActivityB启动ActivityC，C返回结果让A接收，我们平时不知道怎么处理，通过上面源码我们看到可以设置这个标签，就可以完成我们需要的操作。</p>
<p>上面我们在启动失败的时候回直接返回结果，中断操作，调用ActivityStack.sendActivityResultLocked方法。</p>
<h4 id="Step8-ActivityStack-sendActivityResultLocked"><a href="#Step8-ActivityStack-sendActivityResultLocked" class="headerlink" title="Step8.ActivityStack.sendActivityResultLocked"></a>Step8.ActivityStack.sendActivityResultLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">sendActivityResultLocked</span><span class="params">(<span class="type">int</span> callingUid, ActivityRecord r,</span></span><br><span class="line"><span class="params">            String resultWho, <span class="type">int</span> requestCode, <span class="type">int</span> resultCode, Intent data)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (mResumedActivity == r &amp;&amp; r.app != <span class="literal">null</span> &amp;&amp; r.app.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">                r.app.thread.scheduleSendResult(r.appToken, list);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里会调用ApplicationThreadProxy.scheduleSendResult方法。</p>
<h4 id="Step9-ApplicationThreadProxy-scheduleSendResult"><a href="#Step9-ApplicationThreadProxy-scheduleSendResult" class="headerlink" title="Step9.ApplicationThreadProxy.scheduleSendResult"></a>Step9.ApplicationThreadProxy.scheduleSendResult</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">scheduleSendResult</span><span class="params">(IBinder token, List&lt;ResultInfo&gt; results)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    ...</span><br><span class="line">    mRemote.transact(SCHEDULE_SEND_RESULT_TRANSACTION, data, <span class="literal">null</span>,</span><br><span class="line">            IBinder.FLAG_ONEWAY);</span><br><span class="line">    data.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个我们之前在上一章分析广播的时候讲过的，最终会调用ActivityThread.scheduleSendResult方法。</p>
<h4 id="Step10-ActivityThread-scheduleSendResult"><a href="#Step10-ActivityThread-scheduleSendResult" class="headerlink" title="Step10.ActivityThread.scheduleSendResult"></a>Step10.ActivityThread.scheduleSendResult</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">scheduleSendResult</span><span class="params">(IBinder token, List&lt;ResultInfo&gt; results)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    sendMessage(H.SEND_RESULT, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里通过Handler发送消息到ActivityThread.H.handleMessage中进行处理。然后调用handleSendResult方法</p>
<h4 id="Step12-ActivityThread-handleSendResult"><a href="#Step12-ActivityThread-handleSendResult" class="headerlink" title="Step12.ActivityThread.handleSendResult"></a>Step12.ActivityThread.handleSendResult</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleSendResult</span><span class="params">(ResultData res)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">resumed</span> <span class="operator">=</span> !r.paused;</span><br><span class="line">        ...</span><br><span class="line">        deliverResults(r, res.results);</span><br><span class="line">        <span class="keyword">if</span> (resumed) &#123;</span><br><span class="line">            r.activity.performResume();</span><br><span class="line">            r.activity.mTemporaryPause = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用deliverResults方法分发结果，分发完成如果需要复用的，则调用复用方法，这个我们后面会介绍到。</p>
<h4 id="Step13-ActivityThread-deliverResults"><a href="#Step13-ActivityThread-deliverResults" class="headerlink" title="Step13.ActivityThread.deliverResults"></a>Step13.ActivityThread.deliverResults</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deliverResults</span><span class="params">(ActivityClientRecord r, List&lt;ResultInfo&gt; results)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> results.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">            r.activity.dispatchActivityResult(ri.mResultWho,</span><br><span class="line">                    ri.mRequestCode, ri.mResultCode, ri.mData);</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用Activity.dispatchActivityResult方法分发结果。</p>
<h4 id="Step14-Activity-dispatchActivityResult"><a href="#Step14-Activity-dispatchActivityResult" class="headerlink" title="Step14.Activity.dispatchActivityResult"></a>Step14.Activity.dispatchActivityResult</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dispatchActivityResult</span><span class="params">(String who, <span class="type">int</span> requestCode,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> resultCode, Intent data)</span> &#123;</span><br><span class="line">    ....</span><br><span class="line">        onActivityResult(requestCode, resultCode, data);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会调用onActivityResult方法，返回结果，其他的情况这里不介绍了，自己分析一下就好了。到此结果返回就完成了，我们接着分析，再回到Step7，这个方法中有几个发送返回结果的调用，其实调用都是一样的，接着我们分析下面的代码，调用doPendingActivityLaunchesLocked方法，后面还有startActivityUnchecked方法和postStartActivityUncheckedProcessing方法，其实这两个方法也是重复调用，也就是doPendingActivityLaunchesLocked里面也调用了这两个方法，因此我们只分析一次就好了。我们从doPendingActivityLaunchesLocked方法开始分析。</p>
<h4 id="Step16-ActivityStarter-doPendingActivityLaunchesLocked"><a href="#Step16-ActivityStarter-doPendingActivityLaunchesLocked" class="headerlink" title="Step16.ActivityStarter.doPendingActivityLaunchesLocked"></a>Step16.ActivityStarter.doPendingActivityLaunchesLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动等待列表中的Activity，参数doResume传递过来是false</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">doPendingActivityLaunchesLocked</span><span class="params">(<span class="type">boolean</span> doResume)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!mPendingActivityLaunches.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">PendingActivityLaunch</span> <span class="variable">pal</span> <span class="operator">=</span> mPendingActivityLaunches.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 如果mPendingActivityLaunches列表中没有了并且需要复用时设置为复用，这里是false</span></span><br><span class="line">        <span class="comment">// (等待列表中最后一个是最后加进来的，所以需要复用时选择最近的一个进行复用)</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">resume</span> <span class="operator">=</span> doResume &amp;&amp; mPendingActivityLaunches.isEmpty();</span><br><span class="line">        ...</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> startActivityUnchecked(</span><br><span class="line">                    pal.r, pal.sourceRecord, <span class="literal">null</span>, <span class="literal">null</span>, pal.startFlags, resume, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们看到了调用了startActivityUnchecked方法和postStartActivityUncheckedProcessing方法，主要的处理都在startActivityUnchecked方法中，所以下面我们主要看startActivityUnchecked方法，这个方法调用结束启动也就结束了。</p>
<h4 id="Step17-ActivityStarter-startActivityUnchecked"><a href="#Step17-ActivityStarter-startActivityUnchecked" class="headerlink" title="Step17.ActivityStarter.startActivityUnchecked"></a>Step17.ActivityStarter.startActivityUnchecked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个方法调用有两个地方，一个是处理等待的Activity，一个是正常启动Activity</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> r               描述需要被启动的Activity的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceRecord    调用者的Activity的封装</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> voiceSession    等待的为空，否则不为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> voiceInteractor 等待的为空，否则不为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> startFlags      0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> doResume        是否需要复用，等待的不一定需要，直接启动的需要复用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> options         等待的为空，否则不为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inTask          等待的为空，否则不为空</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">startActivityUnchecked</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span><br><span class="line"><span class="params">                                   IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span><br><span class="line"><span class="params">                                   <span class="type">int</span> startFlags, <span class="type">boolean</span> doResume, ActivityOptions options, TaskRecord inTask)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置初始状态</span></span><br><span class="line">    setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession,</span><br><span class="line">            voiceInteractor);</span><br><span class="line"></span><br><span class="line">    computeLaunchingTaskFlags();</span><br><span class="line">    computeSourceStack();</span><br><span class="line">    mIntent.setFlags(mLaunchFlags);</span><br><span class="line">    <span class="comment">// 查找有没有可复用的Activity</span></span><br><span class="line">    mReusedActivity = getReusableIntentActivity();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 如果有可复用的Activity</span></span><br><span class="line">    <span class="keyword">if</span> (mReusedActivity != <span class="literal">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// mStartActivity是在setInitialState方法中赋值的，指向的是被启动Activity对象封装，</span></span><br><span class="line">        <span class="comment">// 如果是第一次启动那么它的任务栈就不存在，此时先默认设置成启动Activity的任务栈。</span></span><br><span class="line">        <span class="keyword">if</span> (mStartActivity.task == <span class="literal">null</span>) &#123;</span><br><span class="line">            mStartActivity.task = mReusedActivity.task;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 这里有三个条件，只需要满足一个就执行if语句中的操作</span></span><br><span class="line">        <span class="comment">// 1.需要清理能复用的Activity所在栈中该Activity上面的其他Activity，</span></span><br><span class="line">        <span class="comment">// 2.该Activity是SingleInstance模式</span></span><br><span class="line">        <span class="comment">// 3.该Activity是SingleTask模式</span></span><br><span class="line">        <span class="keyword">if</span> ((mLaunchFlags &amp; FLAG_ACTIVITY_CLEAR_TOP) != <span class="number">0</span></span><br><span class="line">                || mLaunchSingleInstance || mLaunchSingleTask) &#123;</span><br><span class="line">            <span class="comment">// 获取要启动Activity</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">top</span> <span class="operator">=</span> mReusedActivity.task.performClearTaskForReuseLocked(</span><br><span class="line">                    mStartActivity, mLaunchFlags);</span><br><span class="line">            <span class="keyword">if</span> (top != <span class="literal">null</span>) &#123;</span><br><span class="line">                ...</span><br><span class="line">                top.deliverNewIntentLocked(mCallingUid, mStartActivity.intent,</span><br><span class="line">                        mStartActivity.launchedFromPackage);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sendPowerHintForLaunchStartIfNeeded(<span class="literal">false</span> <span class="comment">/* forceSend */</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将可复用的Activity移到栈顶</span></span><br><span class="line">        mReusedActivity = setTargetStackAndMoveToFrontIfNeeded(mReusedActivity);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((mStartFlags &amp; START_FLAG_ONLY_IF_NEEDED) != <span class="number">0</span>) &#123;</span><br><span class="line">            resumeTargetStackIfNeeded();</span><br><span class="line">            <span class="keyword">return</span> START_RETURN_INTENT_TO_CALLER;</span><br><span class="line">        &#125;</span><br><span class="line">        setTaskFromIntentActivity(mReusedActivity);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不需要添加到任务栈，并且复用TaskRecord为空，说明没有启动一个新的Activity</span></span><br><span class="line">        <span class="comment">// mAddingToTask为false表示要为目标Activity组件创建一个专属任务，事实上函数会检查这个专属</span></span><br><span class="line">        <span class="comment">// 任务是否存在，如果已存在，那么就会将变量mAddingToTask的值设置为true，</span></span><br><span class="line">        <span class="keyword">if</span> (!mAddingToTask &amp;&amp; mReuseTask == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// We didn&#x27;t do anything...  but it was needed (a.k.a., client don&#x27;t use that</span></span><br><span class="line">            <span class="comment">// intent!)  And for paranoia, make sure we have correctly resumed the top activity.</span></span><br><span class="line">            resumeTargetStackIfNeeded();</span><br><span class="line">            <span class="comment">// 需要启动的Activity不需要重启启动，只需要将其放到栈顶即可</span></span><br><span class="line">            <span class="keyword">return</span> START_TASK_TO_FRONT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找不到对应类（Activity）</span></span><br><span class="line">    <span class="keyword">if</span> (mStartActivity.packageName == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mStartActivity.resultTo != <span class="literal">null</span> &amp;&amp; mStartActivity.resultTo.task.stack != <span class="literal">null</span>) &#123;</span><br><span class="line">            mStartActivity.resultTo.task.stack.sendActivityResultLocked(</span><br><span class="line">                    -<span class="number">1</span>, mStartActivity.resultTo, mStartActivity.resultWho,</span><br><span class="line">                    mStartActivity.requestCode, RESULT_CANCELED, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ActivityOptions.abort(mOptions);</span><br><span class="line">        <span class="keyword">return</span> START_CLASS_NOT_FOUND;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the activity being launched is the same as the one currently at the top, then</span></span><br><span class="line">    <span class="comment">// we need to check if it should only be launched once.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityStack</span> <span class="variable">topStack</span> <span class="operator">=</span> mSupervisor.mFocusedStack;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">top</span> <span class="operator">=</span> topStack.topRunningNonDelayedActivityLocked(mNotTop);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (dontStart) &#123;<span class="comment">// 不启动</span></span><br><span class="line">        ...</span><br><span class="line">        topStack.mLastPausedActivity = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (mDoResume) &#123;</span><br><span class="line">            mSupervisor.resumeFocusedStackTopActivityLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        top.deliverNewIntentLocked(</span><br><span class="line">                mCallingUid, mStartActivity.intent, mStartActivity.launchedFromPackage);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 需要启动的Activity在栈顶</span></span><br><span class="line">        <span class="keyword">return</span> START_DELIVERED_TO_TOP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">newTask</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">// 是否会新创建一个任务</span></span><br><span class="line">    <span class="comment">// Activity组件中有一个android:taskAffinity属性，用来描述它的一个专属任务，当AMS决定要将目标</span></span><br><span class="line">    <span class="comment">// Activity运行在一个不同的任务中时，AMS就会检查目标Activity组件的专属任务是否已经存在，如果存</span></span><br><span class="line">    <span class="comment">// 在，那么AMS就会直接将目标Activity组件添加到它里面运行，否则，就会先创建这个专属任务，然后将目</span></span><br><span class="line">    <span class="comment">// 标Activity组件添加到它里面去运行</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">TaskRecord</span> <span class="variable">taskToAffiliate</span> <span class="operator">=</span> (mLaunchTaskBehind &amp;&amp; mSourceRecord != <span class="literal">null</span>)</span><br><span class="line">            ? mSourceRecord.task : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Should this be considered a new task?</span></span><br><span class="line">    <span class="keyword">if</span> (mStartActivity.resultTo == <span class="literal">null</span> &amp;&amp; mInTask == <span class="literal">null</span> &amp;&amp; !mAddingToTask</span><br><span class="line">            &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class="number">0</span>) &#123;</span><br><span class="line">        newTask = <span class="literal">true</span>;</span><br><span class="line">        setTaskFromReuseOrCreateNewTask(taskToAffiliate);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mSourceRecord != <span class="literal">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> setTaskFromSourceRecord();</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mInTask != <span class="literal">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> setTaskFromInTask();</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        setTaskToCurrentTopOrCreateNewTask();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    mTargetStack.startActivityLocked(mStartActivity, newTask, mKeepCurTransition, mOptions);</span><br><span class="line">    <span class="keyword">if</span> (mDoResume) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mLaunchTaskBehind) &#123;</span><br><span class="line">            <span class="comment">// TODO(b/26381750): Remove this code after verification that all the decision</span></span><br><span class="line">            <span class="comment">// points above moved targetStack to the front which will also set the focus</span></span><br><span class="line">            <span class="comment">// activity.</span></span><br><span class="line">            mService.setFocusedActivityLocked(mStartActivity, <span class="string">&quot;startedActivity&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取顶部ActivityRecord</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">topTaskActivity</span> <span class="operator">=</span> mStartActivity.task.topRunningActivityLocked();</span><br><span class="line">        ...</span><br><span class="line">            <span class="comment">// 恢复聚焦栈顶Activity</span></span><br><span class="line">            mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,</span><br><span class="line">                    mOptions);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 添加启动的Activity到最近任务</span></span><br><span class="line">        mTargetStack.addRecentActivityLocked(mStartActivity);</span><br><span class="line">    &#125;</span><br><span class="line">    mSupervisor.updateUserStackLocked(mStartActivity.userId, mTargetStack);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> START_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Activity的启动最核心的东西就在这个方法中，所以这个方法会很复杂，里面调用了很多方法，每个方法分析都会比较复杂，在这个方法最后返回成功，也就是Activity的启动结束标志。下面我们具体分析每一步的具体内容，让我们彻底了解Activity的启动流程。</p>
<h4 id="Step18-ActivityStarter-setInitialState"><a href="#Step18-ActivityStarter-setInitialState" class="headerlink" title="Step18.ActivityStarter.setInitialState"></a>Step18.ActivityStarter.setInitialState</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setInitialState</span><span class="params">(ActivityRecord r, ActivityOptions options, TaskRecord inTask,</span></span><br><span class="line"><span class="params">                             <span class="type">boolean</span> doResume, <span class="type">int</span> startFlags, ActivityRecord sourceRecord,</span></span><br><span class="line"><span class="params">                             IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor)</span> &#123;</span><br><span class="line">    reset();<span class="comment">// 初始化参数</span></span><br><span class="line">    mStartActivity = r;<span class="comment">// 对mStartActivity赋值，也就是被启动的Activity的对象封装</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 判断启动模式，因为默认是standard模式，所以只需要与其他三个对比就可以了</span></span><br><span class="line">    mLaunchSingleTop = r.launchMode == LAUNCH_SINGLE_TOP;</span><br><span class="line">    mLaunchSingleInstance = r.launchMode == LAUNCH_SINGLE_INSTANCE;</span><br><span class="line">    mLaunchSingleTask = r.launchMode == LAUNCH_SINGLE_TASK;</span><br><span class="line">    mLaunchFlags = adjustLaunchFlagsToDocumentMode(</span><br><span class="line">            r, mLaunchSingleInstance, mLaunchSingleTask, mIntent.getFlags());</span><br><span class="line">    <span class="comment">// 通过ActivityOptions.setLaunchTaskBehind方法被激活，并且被启动完成后就会被清理</span></span><br><span class="line">    mLaunchTaskBehind = r.mLaunchTaskBehind</span><br><span class="line">            &amp;&amp; !mLaunchSingleTask &amp;&amp; !mLaunchSingleInstance</span><br><span class="line">            &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_DOCUMENT) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    sendNewTaskResultRequestIfNeeded();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We&#x27;ll invoke onUserLeaving before onPause only if the launching</span></span><br><span class="line">    <span class="comment">// activity did not explicitly state that this is an automated launch.</span></span><br><span class="line">    <span class="comment">// 检查变量mLaunchFlags的Intent.FLAG_ACTIVITY_NO_USER_ACTION位是否为1，如果等于1，那么就</span></span><br><span class="line">    <span class="comment">// 表示目标Activity组件不是由用户手动启动的，如果目标Activity组件是由用户手动启动的，那么用来</span></span><br><span class="line">    <span class="comment">// 启动它的源Activity组件就会获得一个用户离开时间通知，由于目标Activity组件使用户在应用程序启</span></span><br><span class="line">    <span class="comment">// 动器的界面上点击启动的，即变量mLaunchFlags的Intent.FLAG_ACTIVITY_NO_USER_ACTION位等于0，</span></span><br><span class="line">    <span class="comment">// 因此，成员变量mUserLeaving的值为true。</span></span><br><span class="line">    mSupervisor.mUserLeaving = (mLaunchFlags &amp; FLAG_ACTIVITY_NO_USER_ACTION) == <span class="number">0</span>; </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mOptions != <span class="literal">null</span> &amp;&amp; mOptions.getLaunchTaskId() != -<span class="number">1</span> &amp;&amp; mOptions.getTaskOverlay()) &#123;</span><br><span class="line">        r.mTaskOverlay = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 查找所有的栈是否存在对应的TaskRecord</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">TaskRecord</span> <span class="variable">task</span> <span class="operator">=</span> mSupervisor.anyTaskForIdLocked(mOptions.getLaunchTaskId());</span><br><span class="line">        <span class="comment">// 如果存在TaskRecord，那么获取顶部Activity的ActivityRecord</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">top</span> <span class="operator">=</span> task != <span class="literal">null</span> ? task.getTopActivity() : <span class="literal">null</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// intent的标志值的位Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP也没有置位，因此，变量notTop的值为null。</span></span><br><span class="line">    mNotTop = (mLaunchFlags &amp; FLAG_ACTIVITY_PREVIOUS_IS_TOP) != <span class="number">0</span> ? r : <span class="literal">null</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法里面主要是数据初始化，判断启动模式，获取启动标签，为启动Activity做准备。</p>
<h4 id="Step19-ActivityStarter-adjustLaunchFlagsToDocumentMode"><a href="#Step19-ActivityStarter-adjustLaunchFlagsToDocumentMode" class="headerlink" title="Step19.ActivityStarter.adjustLaunchFlagsToDocumentMode"></a>Step19.ActivityStarter.adjustLaunchFlagsToDocumentMode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从前面调用可知，launchFlags是从Intent中获取的，是目标Activity组件启动的标志位，在launchFlags中，</span></span><br><span class="line"><span class="comment"> * 只有Intent.FLAG_ACTIVITY_NEW_TASK位被标记为1，其它位都为0.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> r                    被启动Activity对象封装</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> launchSingleInstance 是不是SingleInstance模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> launchSingleTask     是不是SingleTask模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> launchFlags          启动标记</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">adjustLaunchFlagsToDocumentMode</span><span class="params">(ActivityRecord r, <span class="type">boolean</span> launchSingleInstance,</span></span><br><span class="line"><span class="params">                                            <span class="type">boolean</span> launchSingleTask, <span class="type">int</span> launchFlags)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果launchFlags是FLAG_ACTIVITY_NEW_DOCUMENT模式并且启动模式是singleInstance或者singleTask</span></span><br><span class="line">    <span class="keyword">if</span> ((launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_DOCUMENT) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (launchSingleInstance || launchSingleTask)) &#123;</span><br><span class="line">        <span class="comment">// 如果Intent中的标记为和manifest中的有冲突，则以manifest中的为主</span></span><br><span class="line">        launchFlags &amp;=</span><br><span class="line">                ~(Intent.FLAG_ACTIVITY_NEW_DOCUMENT | FLAG_ACTIVITY_MULTIPLE_TASK);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> launchFlags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要是判断启动标签，这里有个提示，就是如果动态设置的标签和AndroidManifest里面配置的冲突，那么以Manifest文件中为准。</p>
<h4 id="Step20-ActivityStarter-sendNewTaskResultRequestIfNeeded"><a href="#Step20-ActivityStarter-sendNewTaskResultRequestIfNeeded" class="headerlink" title="Step20.ActivityStarter.sendNewTaskResultRequestIfNeeded"></a>Step20.ActivityStarter.sendNewTaskResultRequestIfNeeded</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendNewTaskResultRequestIfNeeded</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 发送条件：接收结果的Activity存在，并且mLaunchFlags是FLAG_ACTIVITY_NEW_TASK，并且接收结果的任务栈存在</span></span><br><span class="line">    <span class="keyword">if</span> (mStartActivity.resultTo != <span class="literal">null</span> &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class="number">0</span></span><br><span class="line">            &amp;&amp; mStartActivity.resultTo.task.stack != <span class="literal">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        mStartActivity.resultTo.task.stack.sendActivityResultLocked(-<span class="number">1</span>, mStartActivity.resultTo,</span><br><span class="line">                mStartActivity.resultWho, mStartActivity.requestCode, RESULT_CANCELED, <span class="literal">null</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里又调用了上面第8步的过程–sendActivityResultLocked方法，这里就不再介绍了，没记住的可以回去看8-14步就可以了。</p>
<h4 id="Step21-ActivityStack-sendActivityResultLocked"><a href="#Step21-ActivityStack-sendActivityResultLocked" class="headerlink" title="Step21.ActivityStack.sendActivityResultLocked"></a>Step21.ActivityStack.sendActivityResultLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">sendActivityResultLocked</span><span class="params">(<span class="type">int</span> callingUid, ActivityRecord r,</span></span><br><span class="line"><span class="params">                              String resultWho, <span class="type">int</span> requestCode, <span class="type">int</span> resultCode, Intent data)</span> &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">            <span class="comment">// 调用onActivityResult</span></span><br><span class="line">            r.app.thread.scheduleSendResult(r.appToken, list);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个过程和上面9-15一样，所以不再讲解。</p>
<h4 id="Step23-ActivityStackSupervisor-anyTaskForIdLocked"><a href="#Step23-ActivityStackSupervisor-anyTaskForIdLocked" class="headerlink" title="Step23.ActivityStackSupervisor.anyTaskForIdLocked"></a>Step23.ActivityStackSupervisor.anyTaskForIdLocked</h4><p>调用下面代码。</p>
<h4 id="Step24-ActivityStackSupervisor-anyTaskForIdLocked"><a href="#Step24-ActivityStackSupervisor-anyTaskForIdLocked" class="headerlink" title="Step24.ActivityStackSupervisor.anyTaskForIdLocked"></a>Step24.ActivityStackSupervisor.anyTaskForIdLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">TaskRecord <span class="title function_">anyTaskForIdLocked</span><span class="params">(<span class="type">int</span> id, <span class="type">boolean</span> restoreFromRecents, <span class="type">int</span> stackId)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里的多个显示一般是可能存在多窗口模式，每一个窗口用ActivityDisplay来表示，它包含了当前窗口存在的所</span></span><br><span class="line">    <span class="comment">// 有栈，这里遍历所有显示任务栈中，查找有没有对应id的任务。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numDisplays</span> <span class="operator">=</span> mActivityDisplays.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">displayNdx</span> <span class="operator">=</span> <span class="number">0</span>; displayNdx &lt; numDisplays; ++displayNdx) &#123;</span><br><span class="line">        ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">stackNdx</span> <span class="operator">=</span> stacks.size() - <span class="number">1</span>; stackNdx &gt;= <span class="number">0</span>; --stackNdx) &#123;</span><br><span class="line">            <span class="type">ActivityStack</span> <span class="variable">stack</span> <span class="operator">=</span> stacks.get(stackNdx);</span><br><span class="line">            <span class="type">TaskRecord</span> <span class="variable">task</span> <span class="operator">=</span> stack.taskForIdLocked(id);</span><br><span class="line">            <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> task;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据任务id查找最近任务列表中是否存在该认为</span></span><br><span class="line">    <span class="type">TaskRecord</span> <span class="variable">task</span> <span class="operator">=</span> mRecentTasks.taskForIdLocked(id);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要是根据任务栈id查找所有屏幕显示的任务列表中是否存在该id对应的任务，如果有直接返回，如果没有从最近任务中查找，没有直接返回null，如果有则调用restoreRecentTaskLocked方法存储该任务。</p>
<h4 id="Step25-ActivityStackSupervisor-restoreRecentTaskLocked"><a href="#Step25-ActivityStackSupervisor-restoreRecentTaskLocked" class="headerlink" title="Step25.ActivityStackSupervisor.restoreRecentTaskLocked"></a>Step25.ActivityStackSupervisor.restoreRecentTaskLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">restoreRecentTaskLocked</span><span class="params">(TaskRecord task, <span class="type">int</span> stackId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (stackId == INVALID_STACK_ID) &#123;<span class="comment">// 无效的id，我们前面传入的就是这个无效的id</span></span><br><span class="line">        stackId = task.getLaunchStackId();<span class="comment">// 获取当前任务的id</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stackId == DOCKED_STACK_ID &amp;&amp; !task.canGoInDockedStack()) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stackId == FREEFORM_WORKSPACE_STACK_ID</span><br><span class="line">            &amp;&amp; mService.mUserController.shouldConfirmCredentials(task.userId)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前任务中的栈管理不为空，说明已经保存了该任务</span></span><br><span class="line">    <span class="keyword">if</span> (task.stack != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Task has already been restored once. See if we need to do anything more</span></span><br><span class="line">        <span class="keyword">if</span> (task.stack.mStackId == stackId) &#123;<span class="comment">// 这里判断任务栈是否在对的栈管理中。</span></span><br><span class="line">            <span class="comment">// Nothing else to do since it is already restored in the right stack.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果我们的任务不在对的栈管理中，我们需要先移除该任务，然后与正确的栈管理进行关联。</span></span><br><span class="line">        task.stack.removeTask(task, <span class="string">&quot;restoreRecentTaskLocked&quot;</span>, REMOVE_TASK_MODE_MOVING);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    stack.addTask(task, <span class="literal">false</span>, <span class="string">&quot;restoreRecentTask&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Step26-ActivityStack-removeTask"><a href="#Step26-ActivityStack-removeTask" class="headerlink" title="Step26.ActivityStack.removeTask"></a>Step26.ActivityStack.removeTask</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">removeTask</span><span class="params">(TaskRecord task, String reason, <span class="type">int</span> mode)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mode == REMOVE_TASK_MODE_DESTROYING) &#123;<span class="comment">// 长在被完全移除栈</span></span><br><span class="line">        mStackSupervisor.removeLockedTaskLocked(task);<span class="comment">// 移除锁定任务</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">r</span> <span class="operator">=</span> mResumedActivity;</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="literal">null</span> &amp;&amp; r.task == task) &#123;<span class="comment">// 存在可复用的Activity，并且是我们正要启动的Activity</span></span><br><span class="line">        mResumedActivity = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskNdx</span> <span class="operator">=</span> mTaskHistory.indexOf(task);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">topTaskNdx</span> <span class="operator">=</span> mTaskHistory.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (task.isOverHomeStack() &amp;&amp; taskNdx &lt; topTaskNdx) &#123;</span><br><span class="line">        <span class="comment">// 获取要移除任务的下一个任务</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">TaskRecord</span> <span class="variable">nextTask</span> <span class="operator">=</span> mTaskHistory.get(taskNdx + <span class="number">1</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    mTaskHistory.remove(task);<span class="comment">// 从历史记录移除</span></span><br><span class="line">    updateTaskMovement(task, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该任务模式为正在被移除销毁，并且该任务中没有已经启动的Activity</span></span><br><span class="line">    <span class="keyword">if</span> (mode == REMOVE_TASK_MODE_DESTROYING &amp;&amp; task.mActivities.isEmpty()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 这里判断是否从最近任务移除该任务</span></span><br><span class="line">        <span class="keyword">if</span> (task.autoRemoveFromRecents() || isVoiceSession) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该栈管理中的历史任务为空，也就是全部被清理了或者没有启动任务</span></span><br><span class="line">    <span class="keyword">if</span> (mTaskHistory.isEmpty()) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    task.stack = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从当前栈中移除传入的任务。</p>
<h4 id="Step27-ActivityStack-addTask"><a href="#Step27-ActivityStack-addTask" class="headerlink" title="Step27.ActivityStack.addTask"></a>Step27.ActivityStack.addTask</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(<span class="keyword">final</span> TaskRecord task, <span class="keyword">final</span> <span class="type">boolean</span> toTop, String reason)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ActivityStack</span> <span class="variable">prevStack</span> <span class="operator">=</span> preAddTask(task, reason, toTop);</span><br><span class="line">        task.stack = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (toTop) &#123;</span><br><span class="line">            insertTaskAtTop(task, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 直接插入到历史任务的最顶部</span></span><br><span class="line">            mTaskHistory.add(<span class="number">0</span>, task);</span><br><span class="line">            updateTaskMovement(task, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        postAddTask(task, prevStack);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>将任务插入到栈中，这里面有个insertTaskAtTop我们后面再讲。</p>
<h4 id="Step28-ActivityStater-computeLaunchingTaskFlags"><a href="#Step28-ActivityStater-computeLaunchingTaskFlags" class="headerlink" title="Step28.ActivityStater.computeLaunchingTaskFlags"></a>Step28.ActivityStater.computeLaunchingTaskFlags</h4><p>这个方法主要是对于mLauncherFlags的处理，这里就不再贴代码。</p>
<h4 id="Step29-ActivityStater-computeSourceStack"><a href="#Step29-ActivityStater-computeSourceStack" class="headerlink" title="Step29.ActivityStater.computeSourceStack"></a>Step29.ActivityStater.computeSourceStack</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">computeSourceStack</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 当前Activity不存在了</span></span><br><span class="line">    <span class="keyword">if</span> (mSourceRecord == <span class="literal">null</span>) &#123;</span><br><span class="line">        mSourceStack = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前Activity没有被finish</span></span><br><span class="line">    <span class="keyword">if</span> (!mSourceRecord.finishing) &#123;</span><br><span class="line">        mSourceStack = mSourceRecord.task.stack;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 如果当前Activity正在被finish，并且启动模式不是启动一个新的任务，那么我们要添加启动新任务的标签。</span></span><br><span class="line">    <span class="keyword">if</span> ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) == <span class="number">0</span>) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;startActivity called from finishing &quot;</span> + mSourceRecord</span><br><span class="line">                + <span class="string">&quot;; forcing &quot;</span> + <span class="string">&quot;Intent.FLAG_ACTIVITY_NEW_TASK for: &quot;</span> + mIntent);</span><br><span class="line">        mLaunchFlags |= FLAG_ACTIVITY_NEW_TASK;</span><br><span class="line">        mNewTaskInfo = mSourceRecord.info;</span><br><span class="line">        mNewTaskIntent = mSourceRecord.task.intent;</span><br><span class="line">    &#125;</span><br><span class="line">    mSourceRecord = <span class="literal">null</span>;</span><br><span class="line">    mSourceStack = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要是获取mSourceStack是否存在。</p>
<h4 id="Step30-ActivityStater-getReusableIntentActivity"><a href="#Step30-ActivityStater-getReusableIntentActivity" class="headerlink" title="Step30.ActivityStater.getReusableIntentActivity"></a>Step30.ActivityStater.getReusableIntentActivity</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 决定新的Activity是否应该被插入到已经存在的任务栈中。如果不插入，返回null，</span></span><br><span class="line"><span class="comment"> * 否则返回一个带有新Activity加入的任务栈的ActivityRecord</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ActivityRecord <span class="title function_">getReusableIntentActivity</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 是否放置到已经存在的任务栈中</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">putIntoExistingTask</span> <span class="operator">=</span> ((mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (mLaunchFlags &amp; FLAG_ACTIVITY_MULTIPLE_TASK) == <span class="number">0</span>)</span><br><span class="line">            || mLaunchSingleInstance || mLaunchSingleTask;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">ActivityRecord</span> <span class="variable">intentActivity</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mOptions != <span class="literal">null</span> &amp;&amp; mOptions.getLaunchTaskId() != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据Id获取任务</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">TaskRecord</span> <span class="variable">task</span> <span class="operator">=</span> mSupervisor.anyTaskForIdLocked(mOptions.getLaunchTaskId());</span><br><span class="line">        <span class="comment">// 如果任务存在启动的Activity就是任务中顶部的Activity</span></span><br><span class="line">        intentActivity = task != <span class="literal">null</span> ? task.getTopActivity() : <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (putIntoExistingTask) &#123;<span class="comment">// 如果需要放到已存在任务中</span></span><br><span class="line">        <span class="keyword">if</span> (mLaunchSingleInstance) &#123;<span class="comment">// SingleInstance模式下，在历史记录中只有一个Activity的实例，并且它一直在它独有的任务栈中。</span></span><br><span class="line">            intentActivity = mSupervisor.findActivityLocked(mIntent, mStartActivity.info, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((mLaunchFlags &amp; FLAG_ACTIVITY_LAUNCH_ADJACENT) != <span class="number">0</span>) &#123;<span class="comment">// 是不是分屏模式</span></span><br><span class="line">            intentActivity = mSupervisor.findActivityLocked(mIntent, mStartActivity.info,</span><br><span class="line">                    !mLaunchSingleTask);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            intentActivity = mSupervisor.findTaskLocked(mStartActivity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intentActivity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是获取一个可复用的Activity，可能存在，也可能为null。</p>
<h4 id="Step31-ActivityStackSupervisor-anyTaskForIdLocked"><a href="#Step31-ActivityStackSupervisor-anyTaskForIdLocked" class="headerlink" title="Step31.ActivityStackSupervisor.anyTaskForIdLocked"></a>Step31.ActivityStackSupervisor.anyTaskForIdLocked</h4><p>这里方法和上面23一样，所以不在讲解，我们接着看36步。</p>
<h4 id="Step36-ActivityStackSupervisor-findActivityLocked"><a href="#Step36-ActivityStackSupervisor-findActivityLocked" class="headerlink" title="Step36.ActivityStackSupervisor.findActivityLocked"></a>Step36.ActivityStackSupervisor.findActivityLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找栈中是否存在与被启动Activity相同的Activity，如果存在取第一个返回，不存在返回空</span></span><br><span class="line">ActivityRecord <span class="title function_">findActivityLocked</span><span class="params">(Intent intent, ActivityInfo info,</span></span><br><span class="line"><span class="params">                                  <span class="type">boolean</span> compareIntentFilters)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">displayNdx</span> <span class="operator">=</span> mActivityDisplays.size() - <span class="number">1</span>; displayNdx &gt;= <span class="number">0</span>; --displayNdx) &#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">stackNdx</span> <span class="operator">=</span> stacks.size() - <span class="number">1</span>; stackNdx &gt;= <span class="number">0</span>; --stackNdx) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">ar</span> <span class="operator">=</span> stacks.get(stackNdx)</span><br><span class="line">                    .findActivityLocked(intent, info, compareIntentFilters);</span><br><span class="line">            <span class="keyword">if</span> (ar != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ar;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据for循环来查找对应的Activity。</p>
<h4 id="Step37-ActivityStack-findActivityLocked"><a href="#Step37-ActivityStack-findActivityLocked" class="headerlink" title="Step37.ActivityStack.findActivityLocked"></a>Step37.ActivityStack.findActivityLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ActivityRecord <span class="title function_">findActivityLocked</span><span class="params">(Intent intent, ActivityInfo info,</span></span><br><span class="line"><span class="params">                                  <span class="type">boolean</span> compareIntentFilters)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">taskNdx</span> <span class="operator">=</span> mTaskHistory.size() - <span class="number">1</span>; taskNdx &gt;= <span class="number">0</span>; --taskNdx) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从栈顶开始，返回第一个与该要启动的Activity相同的Activity，如果没有则返回空</p>
<h4 id="Step38-ActivityStackSupervisor-findTaskLocked"><a href="#Step38-ActivityStackSupervisor-findTaskLocked" class="headerlink" title="Step38.ActivityStackSupervisor.findTaskLocked"></a>Step38.ActivityStackSupervisor.findTaskLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ActivityRecord <span class="title function_">findTaskLocked</span><span class="params">(ActivityRecord r)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">displayNdx</span> <span class="operator">=</span> mActivityDisplays.size() - <span class="number">1</span>; displayNdx &gt;= <span class="number">0</span>; --displayNdx) &#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">stackNdx</span> <span class="operator">=</span> stacks.size() - <span class="number">1</span>; stackNdx &gt;= <span class="number">0</span>; --stackNdx) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 查找栈中是否存在对应的Activity</span></span><br><span class="line">            stack.findTaskLocked(r, mTmpFindTaskResult);</span><br><span class="line">            ..</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_TASKS &amp;&amp; mTmpFindTaskResult.r == <span class="literal">null</span>) Slog.d(TAG_TASKS, <span class="string">&quot;No task found&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mTmpFindTaskResult.r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里考虑到了分屏，查找所有屏幕上是否存在对应的Activity。</p>
<h4 id="Step39-ActivityStack-findTaskLocked"><a href="#Step39-ActivityStack-findTaskLocked" class="headerlink" title="Step39.ActivityStack.findTaskLocked"></a>Step39.ActivityStack.findTaskLocked</h4><p>这个方法没有太复杂的东西，所以不再贴代码，主要根据传入的参数查找存在该Activity的task。</p>
<h4 id="Step40-TaskRecord-performClearTaskForReuseLocked"><a href="#Step40-TaskRecord-performClearTaskForReuseLocked" class="headerlink" title="Step40.TaskRecord.performClearTaskForReuseLocked"></a>Step40.TaskRecord.performClearTaskForReuseLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ActivityRecord <span class="title function_">performClearTaskForReuseLocked</span><span class="params">(ActivityRecord newR, <span class="type">int</span> launchFlags)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">result</span> <span class="operator">=</span> performClearTaskLocked(newR, launchFlags);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用performClearTaskLocked方法：</p>
<h4 id="Step41-TaskRecord-performClearTaskLocked"><a href="#Step41-TaskRecord-performClearTaskLocked" class="headerlink" title="Step41.TaskRecord.performClearTaskLocked"></a>Step41.TaskRecord.performClearTaskLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ActivityRecord <span class="title function_">performClearTaskLocked</span><span class="params">(ActivityRecord newR, <span class="type">int</span> launchFlags)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numActivities</span> <span class="operator">=</span> mActivities.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">activityNdx</span> <span class="operator">=</span> numActivities - <span class="number">1</span>; activityNdx &gt;= <span class="number">0</span>; --activityNdx) &#123;</span><br><span class="line">        <span class="type">ActivityRecord</span> <span class="variable">r</span> <span class="operator">=</span> mActivities.get(activityNdx);</span><br><span class="line">        <span class="keyword">if</span> (r.finishing) &#123;<span class="comment">// 如果正在finish过滤掉</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是要找的Activity，则finish掉所在栈中上面的所有Activity</span></span><br><span class="line">        <span class="keyword">if</span> (r.realActivity.equals(newR.realActivity)) &#123;<span class="comment">// 判断ComponentName（包名类名）</span></span><br><span class="line">            <span class="comment">// Here it is!  Now finish everything in front...</span></span><br><span class="line">            <span class="comment">// 如果包名类名一样，则说明就是要找的和被启动Activity一样的Activity，其实就是要启动这个Activity</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">ret</span> <span class="operator">=</span> r;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (++activityNdx; activityNdx &lt; numActivities; ++activityNdx) &#123;</span><br><span class="line">                r = mActivities.get(activityNdx);</span><br><span class="line">                <span class="keyword">if</span> (r.finishing) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">// 开始清理要启动的Activity上面的Activity</span></span><br><span class="line">                <span class="keyword">if</span> (stack != <span class="literal">null</span> &amp;&amp; stack.finishActivityLocked(</span><br><span class="line">                        r, Activity.RESULT_CANCELED, <span class="literal">null</span>, <span class="string">&quot;clear-task-stack&quot;</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">                    --activityNdx;</span><br><span class="line">                    --numActivities;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是要清理可复用Activity栈中该Activity顶部的Activity，清理调用ActivityStack.finishActivityLocked方法进行清理，这个方法我们在下一章Activity的finish过程再讲。</p>
<h4 id="Step43-ActivityRecord-deliverNewIntentLocked"><a href="#Step43-ActivityRecord-deliverNewIntentLocked" class="headerlink" title="Step43.ActivityRecord.deliverNewIntentLocked"></a>Step43.ActivityRecord.deliverNewIntentLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">deliverNewIntentLocked</span><span class="params">(<span class="type">int</span> callingUid, Intent intent, String referrer)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">            <span class="comment">// 如果正在启动的Activity已经存在，不需要创建新的Activity，则会调用Activity中的onNewIntent</span></span><br><span class="line">            app.thread.scheduleNewIntent(</span><br><span class="line">                    ar, appToken, state == ActivityState.PAUSED <span class="comment">/* andPause */</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>清理完成后，该可复用Activity就会到达栈顶，此时要调用onNewIntent方法，调用过程就是上面scheduleNewIntent开始，后面的步骤和上面10-15基本一样所以不再详细讲解，其实从广播到Activity启动声明周期或者内部方法的调用都是一样的过程，你只要熟悉一个方法的过程，所有方法的过程就全部都会了，所以这里还是比较容易学习的。</p>
<h4 id="Step52-ActivityStarter-setTargetStackAndMoveToFrontIfNeeded"><a href="#Step52-ActivityStarter-setTargetStackAndMoveToFrontIfNeeded" class="headerlink" title="Step52.ActivityStarter.setTargetStackAndMoveToFrontIfNeeded"></a>Step52.ActivityStarter.setTargetStackAndMoveToFrontIfNeeded</h4><p>如果可复用的Activity存在那么就要设置并且将其移到最前面来，也就是栈顶。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ActivityRecord <span class="title function_">setTargetStackAndMoveToFrontIfNeeded</span><span class="params">(ActivityRecord intentActivity)</span> &#123;</span><br><span class="line">     <span class="comment">// 将要启动的Activity所在任务所在的栈作为目标栈</span></span><br><span class="line">     mTargetStack = intentActivity.task.stack;</span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">// 获取当前焦点栈</span></span><br><span class="line">     <span class="keyword">final</span> <span class="type">ActivityStack</span> <span class="variable">focusStack</span> <span class="operator">=</span> mSupervisor.getFocusedStack();</span><br><span class="line">     <span class="comment">// 获取焦点栈中最上面正在运行的非延迟Activity</span></span><br><span class="line">     <span class="type">ActivityRecord</span> <span class="variable">curTop</span> <span class="operator">=</span> (focusStack == <span class="literal">null</span>)</span><br><span class="line">             ? <span class="literal">null</span> : focusStack.topRunningNonDelayedActivityLocked(mNotTop);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 这里三个条件：</span></span><br><span class="line">     <span class="comment">// 1.存在上面获取的Activity，</span></span><br><span class="line">     <span class="comment">// 2.该Activity和要启动Activity不在同一个任务，或者该Activity不是最顶部的任务（也就是不是第一个任务）</span></span><br><span class="line">     <span class="comment">// 3.需要移动到顶部</span></span><br><span class="line">     <span class="keyword">if</span> (curTop != <span class="literal">null</span></span><br><span class="line">             &amp;&amp; (curTop.task != intentActivity.task || curTop.task != focusStack.topTask())</span><br><span class="line">             &amp;&amp; !mAvoidMoveToFront) &#123;</span><br><span class="line">         mStartActivity.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);</span><br><span class="line">         <span class="comment">// 源Activity不存在或者源Activity所在栈顶部Activity存在并且顶部Activity和源Activity不在同一个任务中</span></span><br><span class="line">         <span class="keyword">if</span> (mSourceRecord == <span class="literal">null</span> || (mSourceStack.topActivity() != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                 mSourceStack.topActivity().task == mSourceRecord.task)) &#123;</span><br><span class="line">             ...</span><br><span class="line">             <span class="comment">// 是否创建新任务并且清理该任务中的其他Activity</span></span><br><span class="line">             <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">willClearTask</span> <span class="operator">=</span></span><br><span class="line">                     (mLaunchFlags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))</span><br><span class="line">                             == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK);</span><br><span class="line">             <span class="keyword">if</span> (!willClearTask) &#123;<span class="comment">// 不清理</span></span><br><span class="line">                 <span class="comment">// 获取启动栈</span></span><br><span class="line">                 <span class="keyword">final</span> <span class="type">ActivityStack</span> <span class="variable">launchStack</span> <span class="operator">=</span> getLaunchStack(</span><br><span class="line">                         mStartActivity, mLaunchFlags, mStartActivity.task, mOptions);</span><br><span class="line">                 <span class="comment">// 如果启动栈不存在，或者启动栈不是目标栈</span></span><br><span class="line">                 <span class="keyword">if</span> (launchStack == <span class="literal">null</span> || launchStack == mTargetStack) &#123;</span><br><span class="line">                     <span class="comment">// We only want to move to the front, if we aren&#x27;t going to launch on a</span></span><br><span class="line">                     <span class="comment">// different stack. If we launch on a different stack, we will put the</span></span><br><span class="line">                     <span class="comment">// task on top there.</span></span><br><span class="line">                     <span class="comment">// 把目标栈移动到前台</span></span><br><span class="line">                     mTargetStack.moveTaskToFrontLocked(</span><br><span class="line">                             intentActivity.task, mNoAnimation, mOptions,</span><br><span class="line">                             mStartActivity.appTimeTracker, <span class="string">&quot;bringingFoundTaskToFront&quot;</span>);</span><br><span class="line">                     mMovedToFront = <span class="literal">true</span>;<span class="comment">// 标记</span></span><br><span class="line">                 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (launchStack.mStackId == DOCKED_STACK_ID</span><br><span class="line">                         || launchStack.mStackId == FULLSCREEN_WORKSPACE_STACK_ID) &#123;</span><br><span class="line">                     <span class="comment">// 如果是分屏模式，被启动的Activity会显示到启动它的Activity所在屏幕上</span></span><br><span class="line">                     <span class="keyword">if</span> ((mLaunchFlags &amp; FLAG_ACTIVITY_LAUNCH_ADJACENT) != <span class="number">0</span>) &#123;</span><br><span class="line">                         mSupervisor.moveTaskToStackLocked(intentActivity.task.taskId,</span><br><span class="line">                                 launchStack.mStackId, ON_TOP, FORCE_FOCUS, <span class="string">&quot;launchToSide&quot;</span>,</span><br><span class="line">                                 ANIMATE);</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;<span class="comment">// 不是分屏模式</span></span><br><span class="line">                         mTargetStack.moveTaskToFrontLocked(intentActivity.task, mNoAnimation,</span><br><span class="line">                                 mOptions, mStartActivity.appTimeTracker,</span><br><span class="line">                                 <span class="string">&quot;bringToFrontInsteadOfAdjacentLaunch&quot;</span>);</span><br><span class="line">                     &#125;</span><br><span class="line">             ...</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line">     <span class="keyword">return</span> intentActivity;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这里相对操作复杂，就是如果满足上面三个条件，就要将目标任务移动到前台来，这里调用了两个方法：mTargetStack.moveTaskToFrontLocked和mSupervisor.moveTaskToStackLocked。我们先看第一个：</p>
<h4 id="Step53-ActivityStack-moveTaskToFrontLocked"><a href="#Step53-ActivityStack-moveTaskToFrontLocked" class="headerlink" title="Step53.ActivityStack.moveTaskToFrontLocked"></a>Step53.ActivityStack.moveTaskToFrontLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">moveTaskToFrontLocked</span><span class="params">(TaskRecord tr, <span class="type">boolean</span> noAnimation, ActivityOptions options,</span></span><br><span class="line"><span class="params">                                 AppTimeTracker timeTracker, String reason)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    insertTaskAtTop(tr, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">        addRecentActivityLocked(top);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set focus to the top running activity of this stack.</span></span><br><span class="line">    <span class="type">ActivityRecord</span> <span class="variable">r</span> <span class="operator">=</span> topRunningActivityLocked();</span><br><span class="line">    mService.setFocusedActivityLocked(r, reason);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    mStackSupervisor.resumeFocusedStackTopActivityLocked();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有几个操作：将任务插入到顶部，将最顶部的Activity描述对象放到最近任务的列表中，获取顶部运行的Activity并将其设置为聚焦Activity，我们一个一个分析。</p>
<h4 id="Step54-ActivityStack-insertTaskAtTop"><a href="#Step54-ActivityStack-insertTaskAtTop" class="headerlink" title="Step54.ActivityStack.insertTaskAtTop"></a>Step54.ActivityStack.insertTaskAtTop</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入任务到顶部</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertTaskAtTop</span><span class="params">(TaskRecord task, ActivityRecord newActivity)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLastTaskOverHome</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// If the moving task is over home stack, transfer（转移） its return type to next task</span></span><br><span class="line">    <span class="keyword">if</span> (task.isOverHomeStack()) &#123;<span class="comment">// 当前任务不是普通应用任务</span></span><br><span class="line">        <span class="comment">// 获取相同用户下当前任务的下一个任务</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">TaskRecord</span> <span class="variable">nextTask</span> <span class="operator">=</span> getNextTask(task);</span><br><span class="line">        <span class="keyword">if</span> (nextTask != <span class="literal">null</span>) &#123;<span class="comment">// 存在下一个任务，</span></span><br><span class="line">            <span class="comment">// 则将下一个任务返回任务的类型设置为插入任务的类型</span></span><br><span class="line">            nextTask.setTaskToReturnTo(task.getTaskToReturnTo());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果不存在，那么当前任务就是最后一个了</span></span><br><span class="line">            isLastTaskOverHome = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is being moved to the top by another activity or being launched from the home</span></span><br><span class="line">    <span class="comment">// activity, set mTaskToReturnTo accordingly（相应的）.</span></span><br><span class="line">    <span class="keyword">if</span> (isOnHomeDisplay()) &#123;<span class="comment">// 默认显示屏</span></span><br><span class="line">        <span class="comment">// 获取上一个有焦点的栈管理</span></span><br><span class="line">        <span class="type">ActivityStack</span> <span class="variable">lastStack</span> <span class="operator">=</span> mStackSupervisor.getLastStack();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">fromHome</span> <span class="operator">=</span> lastStack.isHomeStack();</span><br><span class="line">        <span class="keyword">if</span> (!isHomeStack() &amp;&amp; (fromHome || topTask() != task)) &#123;</span><br><span class="line">            <span class="comment">// If it&#x27;s a last task over home - we default to keep its return to type not to</span></span><br><span class="line">            <span class="comment">// make underlying task focused when this one will be finished.</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">returnToType</span> <span class="operator">=</span> isLastTaskOverHome</span><br><span class="line">                    ? task.getTaskToReturnTo() : APPLICATION_ACTIVITY_TYPE;</span><br><span class="line">            <span class="keyword">if</span> (fromHome &amp;&amp; StackId.allowTopTaskToReturnHome(mStackId)) &#123;</span><br><span class="line">                returnToType = lastStack.topTask() == <span class="literal">null</span></span><br><span class="line">                        ? HOME_ACTIVITY_TYPE : lastStack.topTask().taskType;</span><br><span class="line">            &#125;</span><br><span class="line">            task.setTaskToReturnTo(returnToType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        task.setTaskToReturnTo(APPLICATION_ACTIVITY_TYPE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从历史任务中移除该任务</span></span><br><span class="line">    mTaskHistory.remove(task);</span><br><span class="line">    <span class="comment">// Now put task at top.插入任务到顶部</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">taskNdx</span> <span class="operator">=</span> mTaskHistory.size();</span><br><span class="line">    <span class="comment">// 判断是否显示</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">notShownWhenLocked</span> <span class="operator">=</span></span><br><span class="line">            (newActivity != <span class="literal">null</span> &amp;&amp; (newActivity.info.flags &amp; FLAG_SHOW_FOR_ALL_USERS) == <span class="number">0</span>)</span><br><span class="line">                    || (newActivity == <span class="literal">null</span> &amp;&amp; task.topRunningActivityLocked() == <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 如果插入任务不是当前用户的任务，并且也不进行显示</span></span><br><span class="line">    <span class="keyword">if</span> (!mStackSupervisor.isCurrentProfileLocked(task.userId) &amp;&amp; notShownWhenLocked) &#123;</span><br><span class="line">        <span class="comment">// Put non-current user tasks below current user tasks.</span></span><br><span class="line">        <span class="comment">// 这里说明插入的任务不是当前用户的任务，那么从顶部向下查找，一直找到第一不是当前用户的任务的位置，</span></span><br><span class="line">        <span class="keyword">while</span> (--taskNdx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">TaskRecord</span> <span class="variable">tmpTask</span> <span class="operator">=</span> mTaskHistory.get(taskNdx);</span><br><span class="line">            <span class="keyword">if</span> (!mStackSupervisor.isCurrentProfileLocked(tmpTask.userId)</span><br><span class="line">                    || tmpTask.topRunningActivityLocked() == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果插入的任务不是当前用户的，那么就将该非当前用户任务插入到当前用户的任务下面并且在不是当前用户</span></span><br><span class="line">        <span class="comment">// 的任务上面，也就是如果插入任务不是当前用户的那么就要将该任务插入到当前用户任务和非当前用户任务中间</span></span><br><span class="line">        ++taskNdx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入任务</span></span><br><span class="line">    mTaskHistory.add(taskNdx, task);</span><br><span class="line">    updateTaskMovement(task, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面主要是要考虑插入的任务是不是当前用户的任务，如果不是要依次查找非当前用户任务位置，然后将其放置到非当前用户任务的顶部位置。55步是将其添加到最近任务记录中。56步是获取顶部运行的Activity的描述对象。</p>
<h4 id="Step57-ActivityManagerService-setFocusedActivityLocked"><a href="#Step57-ActivityManagerService-setFocusedActivityLocked" class="headerlink" title="Step57.ActivityManagerService.setFocusedActivityLocked"></a>Step57.ActivityManagerService.setFocusedActivityLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">setFocusedActivityLocked</span><span class="params">(ActivityRecord r, String reason)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 将要启动的Activity移动到前台</span></span><br><span class="line">    <span class="keyword">if</span> (mStackSupervisor.moveActivityStackToFront(r, reason + <span class="string">&quot; setFocusedActivity&quot;</span>)) &#123;</span><br><span class="line">        mWindowManager.setFocusedApp(r.appToken, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要是通过调用ActivityStackSupervisor.moveActivityStackToFront方法移动焦点到新的Activity。</p>
<h4 id="Step58-ActivityStackSupervisor-moveActivityStackToFront"><a href="#Step58-ActivityStackSupervisor-moveActivityStackToFront" class="headerlink" title="Step58.ActivityStackSupervisor.moveActivityStackToFront"></a>Step58.ActivityStackSupervisor.moveActivityStackToFront</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将要启动的Activity移动到前台</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">moveActivityStackToFront</span><span class="params">(ActivityRecord r, String reason)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 将任务移动到前台</span></span><br><span class="line">    task.stack.moveToFront(reason, task);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Step59-ActivityStack-moveToFront"><a href="#Step59-ActivityStack-moveToFront" class="headerlink" title="Step59.ActivityStack.moveToFront"></a>Step59.ActivityStack.moveToFront</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">moveToFront</span><span class="params">(String reason, TaskRecord task)</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">         mStackSupervisor.setFocusStackUnchecked(reason, <span class="built_in">this</span>);</span><br><span class="line">     ...</span><br><span class="line">         insertTaskAtTop(task, <span class="literal">null</span>);</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>将任务移动到顶部，方法讲过了看上面的代码分析。</p>
<h4 id="Step60-ActivityStackSupervisor-resumeFocusedStackTopActivityLocked"><a href="#Step60-ActivityStackSupervisor-resumeFocusedStackTopActivityLocked" class="headerlink" title="Step60.ActivityStackSupervisor.resumeFocusedStackTopActivityLocked"></a>Step60.ActivityStackSupervisor.resumeFocusedStackTopActivityLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">resumeFocusedStackTopActivityLocked</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> resumeFocusedStackTopActivityLocked(<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Step61-ActivityStackSupervisor-resumeFocusedStackTopActivityLocked"><a href="#Step61-ActivityStackSupervisor-resumeFocusedStackTopActivityLocked" class="headerlink" title="Step61.ActivityStackSupervisor.resumeFocusedStackTopActivityLocked"></a>Step61.ActivityStackSupervisor.resumeFocusedStackTopActivityLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">resumeFocusedStackTopActivityLocked</span><span class="params">(</span></span><br><span class="line"><span class="params">        ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (targetStack != <span class="literal">null</span> &amp;&amp; isFocusedStack(targetStack)) &#123;<span class="comment">// 如果目标栈存在并且处于聚焦状态，直接启动</span></span><br><span class="line">        <span class="keyword">return</span> targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果目标栈不存在或者没有在聚焦状态，则从聚焦栈中取出栈顶的Activity</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">r</span> <span class="operator">=</span> mFocusedStack.topRunningActivityLocked();</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="literal">null</span> || r.state != RESUMED) &#123;</span><br><span class="line">        mFocusedStack.resumeTopActivityUncheckedLocked(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Step62-ActivityStack-resumeTopActivityUncheckedLocked"><a href="#Step62-ActivityStack-resumeTopActivityUncheckedLocked" class="headerlink" title="Step62.ActivityStack.resumeTopActivityUncheckedLocked"></a>Step62.ActivityStack.resumeTopActivityUncheckedLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">resumeTopActivityUncheckedLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        result = resumeTopActivityInnerLocked(prev, options);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终调用resumeTopActivityInnerLocked方法来进行处理，这个比较复杂，我们放到第二部分分析。我们回到前面接着分析。</p>
<h4 id="Step63-ActivityStackSupervisor-moveTaskToStackLocked"><a href="#Step63-ActivityStackSupervisor-moveTaskToStackLocked" class="headerlink" title="Step63.ActivityStackSupervisor.moveTaskToStackLocked"></a>Step63.ActivityStackSupervisor.moveTaskToStackLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">moveTaskToStackLocked</span><span class="params">(<span class="type">int</span> taskId, <span class="type">int</span> stackId, <span class="type">boolean</span> toTop, <span class="type">boolean</span> forceFocus,</span></span><br><span class="line"><span class="params">                              String reason, <span class="type">boolean</span> animate)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> moveTaskToStackLocked(taskId, stackId, toTop, forceFocus, reason, animate,</span><br><span class="line">            <span class="literal">false</span> <span class="comment">/* deferResume */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Step64-ActivityStackSupervisor-moveTaskToStackLocked"><a href="#Step64-ActivityStackSupervisor-moveTaskToStackLocked" class="headerlink" title="Step64.ActivityStackSupervisor.moveTaskToStackLocked"></a>Step64.ActivityStackSupervisor.moveTaskToStackLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">moveTaskToStackLocked</span><span class="params">(<span class="type">int</span> taskId, <span class="type">int</span> stackId, <span class="type">boolean</span> toTop, <span class="type">boolean</span> forceFocus,</span></span><br><span class="line"><span class="params">                              String reason, <span class="type">boolean</span> animate, <span class="type">boolean</span> deferResume)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据id获取Task描述对象TaskRecord</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">TaskRecord</span> <span class="variable">task</span> <span class="operator">=</span> anyTaskForIdLocked(taskId);</span><br><span class="line">    ...</span><br><span class="line">        resumeFocusedStackTopActivityLocked();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个方法我们前面已经分析过了，这里不再提，第二个方法我们上面Step60已经分析过了。</p>
<h4 id="Step65-ActivityStarter-resumeTargetStackIfNeeded"><a href="#Step65-ActivityStarter-resumeTargetStackIfNeeded" class="headerlink" title="Step65.ActivityStarter.resumeTargetStackIfNeeded"></a>Step65.ActivityStarter.resumeTargetStackIfNeeded</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 恢复目标栈</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resumeTargetStackIfNeeded</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, <span class="literal">null</span>, mOptions);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是上面64中的方法也就是60步。</p>
<h4 id="Step66-ActivityStarter-setTaskFromIntentActivity"><a href="#Step66-ActivityStarter-setTaskFromIntentActivity" class="headerlink" title="Step66.ActivityStarter.setTaskFromIntentActivity"></a>Step66.ActivityStarter.setTaskFromIntentActivity</h4><p>这个方法主要是目标ActivityRecord对象中获取task。代码不多，可以自己看看。</p>
<h4 id="Step68-ActivityStarter-setTaskFromReuseOrCreateNewTask"><a href="#Step68-ActivityStarter-setTaskFromReuseOrCreateNewTask" class="headerlink" title="Step68.ActivityStarter.setTaskFromReuseOrCreateNewTask"></a>Step68.ActivityStarter.setTaskFromReuseOrCreateNewTask</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setTaskFromReuseOrCreateNewTask</span><span class="params">(TaskRecord taskToAffiliate)</span> &#123;</span><br><span class="line">    mTargetStack = computeStackFocus(mStartActivity, <span class="literal">true</span>, mLaunchBounds, mLaunchFlags,</span><br><span class="line">            mOptions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mReuseTask == <span class="literal">null</span>) &#123;<span class="comment">// 没有可用任务</span></span><br><span class="line">        <span class="comment">// 创建新的任务并插入栈中</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">TaskRecord</span> <span class="variable">task</span> <span class="operator">=</span> mTargetStack.createTaskRecord(</span><br><span class="line">                mSupervisor.getNextTaskIdForUserLocked(mStartActivity.userId),</span><br><span class="line">                mNewTaskInfo != <span class="literal">null</span> ? mNewTaskInfo : mStartActivity.info,</span><br><span class="line">                mNewTaskIntent != <span class="literal">null</span> ? mNewTaskIntent : mIntent,</span><br><span class="line">                mVoiceSession, mVoiceInteractor, !mLaunchTaskBehind <span class="comment">/* toTop */</span>);</span><br><span class="line">        mStartActivity.setTask(task, taskToAffiliate);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mStartActivity.setTask(mReuseTask, taskToAffiliate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有可复用的任务就需要创建新的任务，并且添加，如果有就直接添加。</p>
<h4 id="Step71-ActivityStack-startActivityLocked"><a href="#Step71-ActivityStack-startActivityLocked" class="headerlink" title="Step71.ActivityStack.startActivityLocked"></a>Step71.ActivityStack.startActivityLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动Activity（Locked表示线程安全的）</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">startActivityLocked</span><span class="params">(ActivityRecord r, <span class="type">boolean</span> newTask, <span class="type">boolean</span> keepCurTransition,</span></span><br><span class="line"><span class="params">                               ActivityOptions options)</span> &#123;</span><br><span class="line">    <span class="type">TaskRecord</span> <span class="variable">rTask</span> <span class="operator">=</span> r.task;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> rTask.taskId;</span><br><span class="line">    <span class="comment">// mLaunchTaskBehind tasks get placed at the back of the task stack.</span></span><br><span class="line">    <span class="keyword">if</span> (!r.mLaunchTaskBehind &amp;&amp; (taskForIdLocked(taskId) == <span class="literal">null</span> || newTask)) &#123;</span><br><span class="line">        <span class="comment">// Last activity in task had been removed or ActivityManagerService is reusing task.</span></span><br><span class="line">        <span class="comment">// Insert or replace.</span></span><br><span class="line">        <span class="comment">// Might not even be in.</span></span><br><span class="line">        <span class="comment">// task中的上一个activity已被移除，或者AMS重用该task,则将该task移到顶部</span></span><br><span class="line">        insertTaskAtTop(rTask, r);</span><br><span class="line">        mWindowManager.moveTaskToTop(taskId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将目标Activity放到栈顶</span></span><br><span class="line">    task.addActivityToTop(r);</span><br><span class="line">    task.setFrontOfTask();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是将Activity放到栈顶，然后显示。</p>
<h4 id="Step72-ActivityStack-addRecentActivityLocked"><a href="#Step72-ActivityStack-addRecentActivityLocked" class="headerlink" title="Step72.ActivityStack.addRecentActivityLocked"></a>Step72.ActivityStack.addRecentActivityLocked</h4><p>这个方法在55步分析过不再分析。</p>
<p>这里是第一部分的，因此启动过程很复杂所以时序图很多，只能分两部分来讲，很多的代码没有分析，需要的可以去忘得coding拉取代码来看，里面有注释。</p>
<h3 id="第二部分："><a href="#第二部分：" class="headerlink" title="第二部分："></a>第二部分：</h3><p><img src="/images/AndroidOS/007Activity/ActivityStart2.jpg" alt="Activity启动时序图"></p>
<p>这一部分是上面过程的中间一段过程，由于东西比较多，时序图没法画了，所以提取出来单独分析，主要是ActivityStack.resumeTopActivityInnerLocked方法。</p>
<h4 id="Step1-ActivityStack-resumeTopActivityInnerLocked"><a href="#Step1-ActivityStack-resumeTopActivityInnerLocked" class="headerlink" title="Step1.ActivityStack.resumeTopActivityInnerLocked"></a>Step1.ActivityStack.resumeTopActivityInnerLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.当找不到需要resume的Activity，则直接回到桌面；</span></span><br><span class="line"><span class="comment"> * 2.否则，当mResumedActivity不为空，则执行startPausingLocked()暂停该activity;</span></span><br><span class="line"><span class="comment"> * 3.然后再进入startSpecificActivityLocked环节。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> prev    源Activity对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> options</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">resumeTopActivityInnerLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the first activity that is not finishing.</span></span><br><span class="line">    <span class="comment">// 前面我们把要启动的Activity放置在当前Activity组件堆栈的顶端，并且它是正在等待启动的，即它不是</span></span><br><span class="line">    <span class="comment">// 处于结束状态的，因此next就指向了我们将要启动的Activity组件</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">next</span> <span class="operator">=</span> topRunningActivityLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remember how we&#x27;ll process this pause/resume situation, and ensure</span></span><br><span class="line">    <span class="comment">// that the state is reset however we wind up proceeding.</span></span><br><span class="line">    <span class="comment">// 将mUserLeaving放置在userLeaving中，并且重置mUserLeaving为false，因此就可以通过userLeaving</span></span><br><span class="line">    <span class="comment">// 判断是否需要向源Activity组件发送一个用户离开的时间通知了</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">userLeaving</span> <span class="operator">=</span> mStackSupervisor.mUserLeaving;</span><br><span class="line">    mStackSupervisor.mUserLeaving = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">TaskRecord</span> <span class="variable">prevTask</span> <span class="operator">=</span> prev != <span class="literal">null</span> ? prev.task : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;<span class="comment">// 如果要启动的Activity为空，因为我们有要启动的Activity，因此不走这里</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!mFullscreen &amp;&amp; adjustFocusToNextFocusableStackLocked(returnTaskType, reason)) &#123;</span><br><span class="line">            <span class="comment">// Try to move focus to the next visible stack with a running activity if this</span></span><br><span class="line">            <span class="comment">// stack is not covering the entire screen.</span></span><br><span class="line">            <span class="keyword">return</span> mStackSupervisor.resumeFocusedStackTopActivityLocked(</span><br><span class="line">                    mStackSupervisor.getFocusedStack(), prev, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 暂停其他Activity</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pausing</span> <span class="operator">=</span> mStackSupervisor.pauseBackStacks(userLeaving, next, dontWaitForPause);</span><br><span class="line">    <span class="comment">// 我们从一个Activity启动另一个Activity的时候，源Activity不是空，mResumedActivity指向源Activity，</span></span><br><span class="line">    <span class="comment">// 因此mResumedActivity不为空</span></span><br><span class="line">    <span class="keyword">if</span> (mResumedActivity != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">                <span class="string">&quot;resumeTopActivityLocked: Pausing &quot;</span> + mResumedActivity);</span><br><span class="line">        <span class="comment">// 检测是否正在终止一个Activity组件，如果是，那么要等到它中止完成之后再启动Activity组件next</span></span><br><span class="line">        pausing |= startPausingLocked(userLeaving, <span class="literal">false</span>, next, dontWaitForPause);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the most recent activity was noHistory but was only stopped rather</span></span><br><span class="line">    <span class="comment">// than stopped+finished because the device went to sleep, we need to make</span></span><br><span class="line">    <span class="comment">// sure to finish it as we&#x27;re making a new activity topmost.</span></span><br><span class="line">    <span class="keyword">if</span> (mService.isSleepingLocked() &amp;&amp; mLastNoHistoryActivity != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            !mLastNoHistoryActivity.finishing) &#123;</span><br><span class="line">        ...</span><br><span class="line">        requestFinishActivityLocked(mLastNoHistoryActivity.appToken, Activity.RESULT_CANCELED,</span><br><span class="line">                <span class="literal">null</span>, <span class="string">&quot;resume-no-history&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">                    <span class="comment">// 调用onActivityResult函数</span></span><br><span class="line">                    next.app.thread.scheduleSendResult(next.appToken, a);</span><br><span class="line">                ...</span><br><span class="line">                next.app.thread.scheduleNewIntent(</span><br><span class="line">                        next.newIntents, next.appToken, <span class="literal">false</span> <span class="comment">/* andPause */</span>);</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 触发onResume()</span></span><br><span class="line">            next.app.thread.scheduleResumeActivity(next.appToken, next.app.repProcState,</span><br><span class="line">                    mService.isNextTransitionForward(), resumeAnimOptions);</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            mStackSupervisor.startSpecificActivityLocked(next, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">            ...</span><br><span class="line">            requestFinishActivityLocked(next.appToken, Activity.RESULT_CANCELED, <span class="literal">null</span>,</span><br><span class="line">                    <span class="string">&quot;resume-exception&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 目标Activity没有启动会调用startSpecificActivityLocked来启动Activity</span></span><br><span class="line">        mStackSupervisor.startSpecificActivityLocked(next, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数代码量很大，我只留下了核心的一些来分析，其他的可以对照源码进行分析。</p>
<h4 id="Step2-ActivityStack-adjustFocusToNextFocusableStackLocked"><a href="#Step2-ActivityStack-adjustFocusToNextFocusableStackLocked" class="headerlink" title="Step2.ActivityStack.adjustFocusToNextFocusableStackLocked"></a>Step2.ActivityStack.adjustFocusToNextFocusableStackLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">adjustFocusToNextFocusableStackLocked</span><span class="params">(<span class="type">int</span> taskToReturnTo, String reason)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityStack</span> <span class="variable">stack</span> <span class="operator">=</span> getNextFocusableStackLocked();<span class="comment">// 获取下一个有焦点的栈</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">myReason</span> <span class="operator">=</span> reason + <span class="string">&quot; adjustFocusToNextFocusableStack&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (stack == <span class="literal">null</span>) &#123;<span class="comment">// 没有能获取焦点的栈了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取有焦点的顶部运行的Activity对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">top</span> <span class="operator">=</span> stack.topRunningActivityLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果顶部stack是Launcher或者最近任务所在的stack，并且存在该Activity，并且该Activity没有显示</span></span><br><span class="line">    <span class="keyword">if</span> (stack.isHomeStack() &amp;&amp; (top == <span class="literal">null</span> || !top.visible)) &#123;</span><br><span class="line">        <span class="comment">// 那么要显示Launcher或者最近任务</span></span><br><span class="line">        <span class="keyword">return</span> mStackSupervisor.moveHomeStackTaskToTop(taskToReturnTo, reason);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mService.setFocusedActivityLocked(top, myReason);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是获取下一个能够获取焦点的栈，比如最近任务或者Launcher，如果获取不到返回false，如果存在，那么获取该栈的顶部Activity，如果是HomeStack也就是Launcher栈或者最近任务栈，并且顶部Activity没有显示或者不存在则显示Launcher或者最近任务界面。否则设置到AMS中作为焦点Activity，这个函数我们讲过了。</p>
<p>步骤3里的函数我们也分析过了，这里也不再分析，我们开始分析第四步。</p>
<h4 id="Step4-ActivityStackSupervisor-pauseBackStacks"><a href="#Step4-ActivityStackSupervisor-pauseBackStacks" class="headerlink" title="Step4.ActivityStackSupervisor.pauseBackStacks"></a>Step4.ActivityStackSupervisor.pauseBackStacks</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">pauseBackStacks</span><span class="params">(<span class="type">boolean</span> userLeaving, ActivityRecord resuming, <span class="type">boolean</span> dontWait)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">someActivityPaused</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">displayNdx</span> <span class="operator">=</span> mActivityDisplays.size() - <span class="number">1</span>; displayNdx &gt;= <span class="number">0</span>; --displayNdx) &#123;</span><br><span class="line">        ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">stackNdx</span> <span class="operator">=</span> stacks.size() - <span class="number">1</span>; stackNdx &gt;= <span class="number">0</span>; --stackNdx) &#123;</span><br><span class="line">            ...</span><br><span class="line">                someActivityPaused |= stack.startPausingLocked(userLeaving, <span class="literal">false</span>, resuming,</span><br><span class="line">                        dontWait);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> someActivityPaused;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过for循环暂停所有后台栈中的Activity</p>
<h4 id="Step5-ActivityStack-startPausingLocked"><a href="#Step5-ActivityStack-startPausingLocked" class="headerlink" title="Step5.ActivityStack.startPausingLocked"></a>Step5.ActivityStack.startPausingLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">startPausingLocked</span><span class="params">(<span class="type">boolean</span> userLeaving, <span class="type">boolean</span> uiSleeping,</span></span><br><span class="line"><span class="params">                                 ActivityRecord resuming, <span class="type">boolean</span> dontWait)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mPausingActivity != <span class="literal">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">            completePauseLocked(<span class="literal">false</span>, resuming);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要暂停的Activity不为空，那么要完成暂停操作。</p>
<h4 id="Step6-ActivityStack-completePauseLocked"><a href="#Step6-ActivityStack-completePauseLocked" class="headerlink" title="Step6.ActivityStack.completePauseLocked"></a>Step6.ActivityStack.completePauseLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">completePauseLocked</span><span class="params">(<span class="type">boolean</span> resumeNext, ActivityRecord resuming)</span> &#123;</span><br><span class="line">    <span class="type">ActivityRecord</span> <span class="variable">prev</span> <span class="operator">=</span> mPausingActivity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在前面我们将mPausingActivity指向了与源Activity组件对应的ActivityRecord对象，此处为true</span></span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 表示源Activity状态已经是Paused状态了</span></span><br><span class="line">        prev.state = ActivityState.PAUSED;</span><br><span class="line">        <span class="keyword">if</span> (prev.finishing) &#123;<span class="comment">// 如果是正在结束</span></span><br><span class="line">            prev = finishCurrentActivityLocked(prev, FINISH_AFTER_VISIBLE, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prev.app != <span class="literal">null</span>) &#123;<span class="comment">// 进程还存在</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (prev.deferRelaunchUntilPaused) &#123;</span><br><span class="line">                <span class="comment">// Complete the deferred relaunch that was waiting for pause to complete.</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_PAUSE) Slog.v(TAG_PAUSE, <span class="string">&quot;Re-launching after pause: &quot;</span> + prev);</span><br><span class="line">                relaunchActivityLocked(prev, prev.configChangeFlags, <span class="literal">false</span>,</span><br><span class="line">                        prev.preserveWindowOnDeferredRelaunch);</span><br><span class="line">            &#125; </span><br><span class="line">            ...</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>finish的过程我们下一章再分析，我们下面分析一个核心的函数relaunchActivityLocked，由于下面会涉及Activity的启动，因此我们通过这个函数直接来分析。</p>
<h4 id="Step7-ActivityStack-relaunchActivityLocked"><a href="#Step7-ActivityStack-relaunchActivityLocked" class="headerlink" title="Step7.ActivityStack.relaunchActivityLocked"></a>Step7.ActivityStack.relaunchActivityLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">relaunchActivityLocked</span><span class="params">(</span></span><br><span class="line"><span class="params">        ActivityRecord r, <span class="type">int</span> changes, <span class="type">boolean</span> andResume, <span class="type">boolean</span> preserveWindow)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        r.app.thread.scheduleRelaunchActivity(r.appToken, results, newIntents, changes,</span><br><span class="line">                !andResume, <span class="keyword">new</span> <span class="title class_">Configuration</span>(mService.mConfiguration),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Configuration</span>(r.task.mOverrideConfig), preserveWindow);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到什么代码应该很熟悉了，调用ApplicationThreadProxy.scheduleRelaunchActivity方法然后通过Binder调用ApplicationThread.scheduleRelaunchActivity函数。我这里的图就省略了中间的过程。但是要知道这个过程。</p>
<h4 id="Step8-ApplicationThread-scheduleRelaunchActivity"><a href="#Step8-ApplicationThread-scheduleRelaunchActivity" class="headerlink" title="Step8.ApplicationThread.scheduleRelaunchActivity"></a>Step8.ApplicationThread.scheduleRelaunchActivity</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">scheduleRelaunchActivity</span><span class="params">(IBinder token,</span></span><br><span class="line"><span class="params">                                           List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span></span><br><span class="line"><span class="params">                                           <span class="type">int</span> configChanges, <span class="type">boolean</span> notResumed, Configuration config,</span></span><br><span class="line"><span class="params">                                           Configuration overrideConfig, <span class="type">boolean</span> preserveWindow)</span> &#123;</span><br><span class="line">    requestRelaunchActivity(token, pendingResults, pendingNewIntents,</span><br><span class="line">            configChanges, notResumed, config, overrideConfig, <span class="literal">true</span>, preserveWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Step9-ActivityThread-requestRelaunchActivity"><a href="#Step9-ActivityThread-requestRelaunchActivity" class="headerlink" title="Step9.ActivityThread.requestRelaunchActivity"></a>Step9.ActivityThread.requestRelaunchActivity</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">requestRelaunchActivity</span><span class="params">(IBinder token,</span></span><br><span class="line"><span class="params">                                          List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span></span><br><span class="line"><span class="params">                                          <span class="type">int</span> configChanges, <span class="type">boolean</span> notResumed, Configuration config,</span></span><br><span class="line"><span class="params">                                          Configuration overrideConfig, <span class="type">boolean</span> fromServer, <span class="type">boolean</span> preserveWindow)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">            sendMessage(H.RELAUNCH_ACTIVITY, target);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个过程应该很熟悉了，所以这里不再多解释。后面就直接分析过程了。这里回到ActivityThread.H的handleMessage方法中，然后调用ActivityThread.handleRelaunchActivity方法。</p>
<h4 id="Step10-ActivityThread-handleRelaunchActivity"><a href="#Step10-ActivityThread-handleRelaunchActivity" class="headerlink" title="Step10.ActivityThread.handleRelaunchActivity"></a>Step10.ActivityThread.handleRelaunchActivity</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleRelaunchActivity</span><span class="params">(ActivityClientRecord tmp)</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">// Need to ensure state is saved.</span></span><br><span class="line">     <span class="keyword">if</span> (!r.paused) &#123;</span><br><span class="line">         performPauseActivity(r.token, <span class="literal">false</span>, r.isPreHoneycomb(), <span class="string">&quot;handleRelaunchActivity&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (r.state == <span class="literal">null</span> &amp;&amp; !r.stopped &amp;&amp; !r.isPreHoneycomb()) &#123;</span><br><span class="line">         callCallActivityOnSaveInstanceState(r);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     handleDestroyActivity(r.token, <span class="literal">false</span>, configChanges, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">     handleLaunchActivity(r, currentIntent, <span class="string">&quot;handleRelaunchActivity&quot;</span>);</span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这里performPauseActivity会根据12-17步一直执行到Activity.onPause方法。<br>callCallActivityOnSaveInstanceState方法会执行18-21步骤最终执行Activity.onSaveInstanceState方法。<br>handleDestroyActivity方法会执行到Activity.onDestroy方法。<br>这些过程都很简单跟着代码走一下就都知道了，过程基本相同。</p>
<h4 id="Step23-ActivityThread-handleLaunchActivity"><a href="#Step23-ActivityThread-handleLaunchActivity" class="headerlink" title="Step23.ActivityThread.handleLaunchActivity"></a>Step23.ActivityThread.handleLaunchActivity</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动Activity</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent, String reason)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure we are running with the most recent config.</span></span><br><span class="line">    <span class="comment">// 最终回调目标Activity的onConfigurationChanged()</span></span><br><span class="line">    handleConfigurationChanged(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先调用performLaunchActivity方法将目标Activity组件启动起来，最终调用目标Activity的onCreate方法</span></span><br><span class="line">    <span class="type">Activity</span> <span class="variable">a</span> <span class="operator">=</span> performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a != <span class="literal">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 最终回调目标Activity的onStart,onResume.</span></span><br><span class="line">        handleResumeActivity(r.token, <span class="literal">false</span>, r.isForward,</span><br><span class="line">                !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123;</span><br><span class="line">            ...</span><br><span class="line">            performPauseActivityIfNeeded(r, reason);</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中handleConfigurationChanged方法最终会调用Activity.onConfigurationChanged方法。handleResumeActivity方法最终会调用Activity.onResume方法。最主要还是看performLaunchActivity方法。</p>
<h4 id="Step28-ActivityThread-performLaunchActivity"><a href="#Step28-ActivityThread-performLaunchActivity" class="headerlink" title="Step28.ActivityThread.performLaunchActivity"></a>Step28.ActivityThread.performLaunchActivity</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Activity <span class="title function_">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="type">Activity</span> <span class="variable">activity</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将目标Activity的类文件加载到内存中，并创建一个实例。由于所有Activity组件都是从Activity类</span></span><br><span class="line">        <span class="comment">// 继承下来的，因此，我们就可以将前面创建的Activity组件保存在Activity对象activity中</span></span><br><span class="line">        java.lang.<span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> r.packageInfo.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Application对象</span></span><br><span class="line">        <span class="type">Application</span> <span class="variable">app</span> <span class="operator">=</span> r.packageInfo.makeApplication(<span class="literal">false</span>, mInstrumentation);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (activity != <span class="literal">null</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 使用ContextImpl对象appContext和ActivityClientRecord对象r来初始化Activity对象activity</span></span><br><span class="line">            activity.attach(appContext, <span class="built_in">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor, window);</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            <span class="type">int</span> <span class="variable">theme</span> <span class="operator">=</span> r.activityInfo.getThemeResource();</span><br><span class="line">            <span class="keyword">if</span> (theme != <span class="number">0</span>) &#123;</span><br><span class="line">                activity.setTheme(theme);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            activity.mCalled = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 调用成员变量mInstrumentation的callActivityOnCreate方法将Activity对象activity启动起来，</span></span><br><span class="line">            <span class="comment">// 会调用Activity的onCreate方法</span></span><br><span class="line">            <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (!r.activity.mFinished) &#123;</span><br><span class="line">                activity.performStart();</span><br><span class="line">                r.stopped = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!r.activity.mFinished) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (r.state != <span class="literal">null</span> || r.persistentState != <span class="literal">null</span>) &#123;</span><br><span class="line">                        mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</span><br><span class="line">                                r.persistentState);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.state != <span class="literal">null</span>) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个启动过程：<br>通过29步加载Activity，<br>然后通过31步创建Application，<br>在35步调用Application的onCreate方法，<br>37步调用Activity的attach方法，<br>38步设置主题，<br>39步调用Activity的onCreate方法，<br>42步调用Activity的onStart方法，<br>45步调用Activity的onRestoreInstanceState方法，<br>然后回到ActivityThread.handleLaunchActivity方法执行handleResumeActivity方法，也就是48步以后；<br>在调用onResume函数之前可能会先调用onNewIntent方法和onActivityResult方法，这样一来onResume函数之前的一个流程基本就出来了，由于代码比较简单，这里不再贴代码，自己跟着这个流程自己看看就知道了。</p>
<p>再看65步到67步，这个是从外面调用onActivityResult、onNewIntent和onResume方法的和第一部分的8-15步一样，可以参考前面的就好了。</p>
<p>最后68-70步其实还是会执行到handleLaunchActivity方法上来，所以这里就不再分析。</p>
<p>从整篇文章看，Activity的启动流程是非常复杂，可以说在四大组件中是最复杂的，但是里面很多过程是相同的，比如生命周期的每个方法的调用过程基本是一样的，因此看书谷歌工程师设计的巧妙，这样也有助于我们对于源码的学习，减少了我们对于源码的分析过程，博客写了很多，但是对于整个过程来说还是很多地方没有分析，想了解完整的过程的可以下载我的代码，里面有很全面的注释，然后自己对着上面的时序图来进行分析，过几遍也就熟悉了，我写这片博客也用了很长的时间，主要是中间总是有事，写写停停，时序图更改了好几次。中间也有一些问题，不过跟着源码走还是都能找到的。</p>
<h2 id="代码地址："><a href="#代码地址：" class="headerlink" title="代码地址："></a>代码地址：</h2><p>直接拉取导入开发工具（Intellij idea或者Android studio）</p>
<p><a target="_blank" rel="noopener" href="https://github.com/yuchuangu85/Android_Framework_Source">Android_Framework_Source</a></p>
<h2 id="注"><a href="#注" class="headerlink" title="注"></a>注</h2><p>Android开发群：192508518</p>
<p>微信公众账号：Code-MX<br><img width="240" src="/images/codemx/qr_code_mx.jpg"/></p>
<p>注：本文原创，转载请注明出处，多谢。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://www.codemx.cn">墨香</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://www.codemx.cn/2018/01/26/AndroidOS008-Activity/">http://www.codemx.cn/2018/01/26/AndroidOS008-Activity/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.codemx.cn" target="_blank">墨香博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/AndroidOS/">AndroidOS</a></div><div class="post-share"><div class="social-share" data-image="/img/head.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="prev-post pull-left" href="/2018/03/12/AndroidOS009-Activity/" title="Android系统源码分析--Activity的finish过程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android系统源码分析--Activity的finish过程</div></div></a><a class="next-post pull-right" href="/2017/12/25/AndroidOS007-Broadcast2/" title="Android系统源码分析--Broadcast发送"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android系统源码分析--Broadcast发送</div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a href="/2017/06/05/AndroidOS002-Context/" title="Android系统源码分析--Context"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-06-05</div><div class="title">Android系统源码分析--Context</div></div></a><a href="/2017/06/03/AndroidOS001/" title="IntelliJ IDEA导入Android源码"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-06-03</div><div class="title">IntelliJ IDEA导入Android源码</div></div></a><a href="/2017/07/12/AndroidOS003-SystemServer/" title="Android系统源码分析--Zygote和SystemServer启动过程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-07-12</div><div class="title">Android系统源码分析--Zygote和SystemServer启动过程</div></div></a><a href="/2017/07/13/AndroidOS004-HandleMessageLooper/" title="Android系统源码分析--消息循环机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-07-13</div><div class="title">Android系统源码分析--消息循环机制</div></div></a><a href="/2017/09/13/AndroidOS005-Process/" title="Android系统源码分析--Process启动过程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-09-13</div><div class="title">Android系统源码分析--Process启动过程</div></div></a><a href="/2017/12/25/AndroidOS007-Broadcast2/" title="Android系统源码分析--Broadcast发送"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-12-25</div><div class="title">Android系统源码分析--Broadcast发送</div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">墨香</div><div class="author-info-description">因为兴趣所以选择，因为选择所以坚持。</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yuchuangu85"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/yuchuangu85" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:yuchuangu85@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">路虽远，行则将至；事虽难，做则可成。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Activity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">Activity启动模式简介：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Activity%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">Activity源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">第一部分：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Step1-startActivityForResult"><span class="toc-number">2.1.1.</span> <span class="toc-text">Step1.startActivityForResult:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step2-Instrumentation-execStartActivity"><span class="toc-number">2.1.2.</span> <span class="toc-text">Step2.Instrumentation.execStartActivity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step3-ActivityManagerProxy-startActivity"><span class="toc-number">2.1.3.</span> <span class="toc-text">Step3.ActivityManagerProxy.startActivity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step4-AMS-startActivity"><span class="toc-number">2.1.4.</span> <span class="toc-text">Step4.AMS.startActivity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step5-AMS-startActivityAsUser"><span class="toc-number">2.1.5.</span> <span class="toc-text">Step5.AMS.startActivityAsUser</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step6-ActivityStarter-startActivityMayWait"><span class="toc-number">2.1.6.</span> <span class="toc-text">Step6.ActivityStarter.startActivityMayWait</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step7-startActivityLocked"><span class="toc-number">2.1.7.</span> <span class="toc-text">Step7.startActivityLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step8-ActivityStack-sendActivityResultLocked"><span class="toc-number">2.1.8.</span> <span class="toc-text">Step8.ActivityStack.sendActivityResultLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step9-ApplicationThreadProxy-scheduleSendResult"><span class="toc-number">2.1.9.</span> <span class="toc-text">Step9.ApplicationThreadProxy.scheduleSendResult</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step10-ActivityThread-scheduleSendResult"><span class="toc-number">2.1.10.</span> <span class="toc-text">Step10.ActivityThread.scheduleSendResult</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step12-ActivityThread-handleSendResult"><span class="toc-number">2.1.11.</span> <span class="toc-text">Step12.ActivityThread.handleSendResult</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step13-ActivityThread-deliverResults"><span class="toc-number">2.1.12.</span> <span class="toc-text">Step13.ActivityThread.deliverResults</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step14-Activity-dispatchActivityResult"><span class="toc-number">2.1.13.</span> <span class="toc-text">Step14.Activity.dispatchActivityResult</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step16-ActivityStarter-doPendingActivityLaunchesLocked"><span class="toc-number">2.1.14.</span> <span class="toc-text">Step16.ActivityStarter.doPendingActivityLaunchesLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step17-ActivityStarter-startActivityUnchecked"><span class="toc-number">2.1.15.</span> <span class="toc-text">Step17.ActivityStarter.startActivityUnchecked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step18-ActivityStarter-setInitialState"><span class="toc-number">2.1.16.</span> <span class="toc-text">Step18.ActivityStarter.setInitialState</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step19-ActivityStarter-adjustLaunchFlagsToDocumentMode"><span class="toc-number">2.1.17.</span> <span class="toc-text">Step19.ActivityStarter.adjustLaunchFlagsToDocumentMode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step20-ActivityStarter-sendNewTaskResultRequestIfNeeded"><span class="toc-number">2.1.18.</span> <span class="toc-text">Step20.ActivityStarter.sendNewTaskResultRequestIfNeeded</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step21-ActivityStack-sendActivityResultLocked"><span class="toc-number">2.1.19.</span> <span class="toc-text">Step21.ActivityStack.sendActivityResultLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step23-ActivityStackSupervisor-anyTaskForIdLocked"><span class="toc-number">2.1.20.</span> <span class="toc-text">Step23.ActivityStackSupervisor.anyTaskForIdLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step24-ActivityStackSupervisor-anyTaskForIdLocked"><span class="toc-number">2.1.21.</span> <span class="toc-text">Step24.ActivityStackSupervisor.anyTaskForIdLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step25-ActivityStackSupervisor-restoreRecentTaskLocked"><span class="toc-number">2.1.22.</span> <span class="toc-text">Step25.ActivityStackSupervisor.restoreRecentTaskLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step26-ActivityStack-removeTask"><span class="toc-number">2.1.23.</span> <span class="toc-text">Step26.ActivityStack.removeTask</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step27-ActivityStack-addTask"><span class="toc-number">2.1.24.</span> <span class="toc-text">Step27.ActivityStack.addTask</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step28-ActivityStater-computeLaunchingTaskFlags"><span class="toc-number">2.1.25.</span> <span class="toc-text">Step28.ActivityStater.computeLaunchingTaskFlags</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step29-ActivityStater-computeSourceStack"><span class="toc-number">2.1.26.</span> <span class="toc-text">Step29.ActivityStater.computeSourceStack</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step30-ActivityStater-getReusableIntentActivity"><span class="toc-number">2.1.27.</span> <span class="toc-text">Step30.ActivityStater.getReusableIntentActivity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step31-ActivityStackSupervisor-anyTaskForIdLocked"><span class="toc-number">2.1.28.</span> <span class="toc-text">Step31.ActivityStackSupervisor.anyTaskForIdLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step36-ActivityStackSupervisor-findActivityLocked"><span class="toc-number">2.1.29.</span> <span class="toc-text">Step36.ActivityStackSupervisor.findActivityLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step37-ActivityStack-findActivityLocked"><span class="toc-number">2.1.30.</span> <span class="toc-text">Step37.ActivityStack.findActivityLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step38-ActivityStackSupervisor-findTaskLocked"><span class="toc-number">2.1.31.</span> <span class="toc-text">Step38.ActivityStackSupervisor.findTaskLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step39-ActivityStack-findTaskLocked"><span class="toc-number">2.1.32.</span> <span class="toc-text">Step39.ActivityStack.findTaskLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step40-TaskRecord-performClearTaskForReuseLocked"><span class="toc-number">2.1.33.</span> <span class="toc-text">Step40.TaskRecord.performClearTaskForReuseLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step41-TaskRecord-performClearTaskLocked"><span class="toc-number">2.1.34.</span> <span class="toc-text">Step41.TaskRecord.performClearTaskLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step43-ActivityRecord-deliverNewIntentLocked"><span class="toc-number">2.1.35.</span> <span class="toc-text">Step43.ActivityRecord.deliverNewIntentLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step52-ActivityStarter-setTargetStackAndMoveToFrontIfNeeded"><span class="toc-number">2.1.36.</span> <span class="toc-text">Step52.ActivityStarter.setTargetStackAndMoveToFrontIfNeeded</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step53-ActivityStack-moveTaskToFrontLocked"><span class="toc-number">2.1.37.</span> <span class="toc-text">Step53.ActivityStack.moveTaskToFrontLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step54-ActivityStack-insertTaskAtTop"><span class="toc-number">2.1.38.</span> <span class="toc-text">Step54.ActivityStack.insertTaskAtTop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step57-ActivityManagerService-setFocusedActivityLocked"><span class="toc-number">2.1.39.</span> <span class="toc-text">Step57.ActivityManagerService.setFocusedActivityLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step58-ActivityStackSupervisor-moveActivityStackToFront"><span class="toc-number">2.1.40.</span> <span class="toc-text">Step58.ActivityStackSupervisor.moveActivityStackToFront</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step59-ActivityStack-moveToFront"><span class="toc-number">2.1.41.</span> <span class="toc-text">Step59.ActivityStack.moveToFront</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step60-ActivityStackSupervisor-resumeFocusedStackTopActivityLocked"><span class="toc-number">2.1.42.</span> <span class="toc-text">Step60.ActivityStackSupervisor.resumeFocusedStackTopActivityLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step61-ActivityStackSupervisor-resumeFocusedStackTopActivityLocked"><span class="toc-number">2.1.43.</span> <span class="toc-text">Step61.ActivityStackSupervisor.resumeFocusedStackTopActivityLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step62-ActivityStack-resumeTopActivityUncheckedLocked"><span class="toc-number">2.1.44.</span> <span class="toc-text">Step62.ActivityStack.resumeTopActivityUncheckedLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step63-ActivityStackSupervisor-moveTaskToStackLocked"><span class="toc-number">2.1.45.</span> <span class="toc-text">Step63.ActivityStackSupervisor.moveTaskToStackLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step64-ActivityStackSupervisor-moveTaskToStackLocked"><span class="toc-number">2.1.46.</span> <span class="toc-text">Step64.ActivityStackSupervisor.moveTaskToStackLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step65-ActivityStarter-resumeTargetStackIfNeeded"><span class="toc-number">2.1.47.</span> <span class="toc-text">Step65.ActivityStarter.resumeTargetStackIfNeeded</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step66-ActivityStarter-setTaskFromIntentActivity"><span class="toc-number">2.1.48.</span> <span class="toc-text">Step66.ActivityStarter.setTaskFromIntentActivity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step68-ActivityStarter-setTaskFromReuseOrCreateNewTask"><span class="toc-number">2.1.49.</span> <span class="toc-text">Step68.ActivityStarter.setTaskFromReuseOrCreateNewTask</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step71-ActivityStack-startActivityLocked"><span class="toc-number">2.1.50.</span> <span class="toc-text">Step71.ActivityStack.startActivityLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step72-ActivityStack-addRecentActivityLocked"><span class="toc-number">2.1.51.</span> <span class="toc-text">Step72.ActivityStack.addRecentActivityLocked</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A"><span class="toc-number">2.2.</span> <span class="toc-text">第二部分：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Step1-ActivityStack-resumeTopActivityInnerLocked"><span class="toc-number">2.2.1.</span> <span class="toc-text">Step1.ActivityStack.resumeTopActivityInnerLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step2-ActivityStack-adjustFocusToNextFocusableStackLocked"><span class="toc-number">2.2.2.</span> <span class="toc-text">Step2.ActivityStack.adjustFocusToNextFocusableStackLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step4-ActivityStackSupervisor-pauseBackStacks"><span class="toc-number">2.2.3.</span> <span class="toc-text">Step4.ActivityStackSupervisor.pauseBackStacks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step5-ActivityStack-startPausingLocked"><span class="toc-number">2.2.4.</span> <span class="toc-text">Step5.ActivityStack.startPausingLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step6-ActivityStack-completePauseLocked"><span class="toc-number">2.2.5.</span> <span class="toc-text">Step6.ActivityStack.completePauseLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step7-ActivityStack-relaunchActivityLocked"><span class="toc-number">2.2.6.</span> <span class="toc-text">Step7.ActivityStack.relaunchActivityLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step8-ApplicationThread-scheduleRelaunchActivity"><span class="toc-number">2.2.7.</span> <span class="toc-text">Step8.ApplicationThread.scheduleRelaunchActivity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step9-ActivityThread-requestRelaunchActivity"><span class="toc-number">2.2.8.</span> <span class="toc-text">Step9.ActivityThread.requestRelaunchActivity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step10-ActivityThread-handleRelaunchActivity"><span class="toc-number">2.2.9.</span> <span class="toc-text">Step10.ActivityThread.handleRelaunchActivity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step23-ActivityThread-handleLaunchActivity"><span class="toc-number">2.2.10.</span> <span class="toc-text">Step23.ActivityThread.handleLaunchActivity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step28-ActivityThread-performLaunchActivity"><span class="toc-number">2.2.11.</span> <span class="toc-text">Step28.ActivityThread.performLaunchActivity</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9C%B0%E5%9D%80%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">代码地址：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8"><span class="toc-number">4.</span> <span class="toc-text">注</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/25/Google-Jetpack-Compose-Animation/" title="Google-Jetpack-Compose-Animation">Google-Jetpack-Compose-Animation</a><time datetime="2024-08-24T16:54:13.000Z" title="发表于 2024-08-25 00:54:13">2024-08-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/24/ANR03/" title="ANR-分析之基础知识介绍：event log">ANR-分析之基础知识介绍：event log</a><time datetime="2024-08-24T15:41:04.000Z" title="发表于 2024-08-24 23:41:04">2024-08-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/19/ANR02/" title="ANR-分析之基础知识介绍：trace信息">ANR-分析之基础知识介绍：trace信息</a><time datetime="2024-08-19T14:58:58.000Z" title="发表于 2024-08-19 22:58:58">2024-08-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/17/ANR01/" title="ANR-分类以及分析流程">ANR-分类以及分析流程</a><time datetime="2024-08-17T15:24:39.000Z" title="发表于 2024-08-17 23:24:39">2024-08-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/01/Google-App-architecture/" title="Google官方Android开发资料整理之-App architecture(架构)">Google官方Android开发资料整理之-App architecture(架构)</a><time datetime="2024-07-01T15:51:46.000Z" title="发表于 2024-07-01 23:51:46">2024-07-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2016 - 2024 By 墨香</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>