<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Android系统源码分析--Broadcast发送 | 墨香博客</title><meta name="author" content="墨香"><meta name="copyright" content="墨香"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="上一篇分析了Android系统中广播的注册和注销，这一篇我们继续分析发送广播的源码流程，广播的发送相对来说比较复杂，所以需要比较长的时间来看，如果你看懂了流程相对来说再研究流程中的细节就比较简单了。">
<meta property="og:type" content="article">
<meta property="og:title" content="Android系统源码分析--Broadcast发送">
<meta property="og:url" content="http://www.codemx.cn/2017/12/25/AndroidOS007-Broadcast2/index.html">
<meta property="og:site_name" content="墨香博客">
<meta property="og:description" content="上一篇分析了Android系统中广播的注册和注销，这一篇我们继续分析发送广播的源码流程，广播的发送相对来说比较复杂，所以需要比较长的时间来看，如果你看懂了流程相对来说再研究流程中的细节就比较简单了。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.codemx.cn/img/head.jpg">
<meta property="article:published_time" content="2017-12-25T09:08:52.000Z">
<meta property="article:modified_time" content="2024-07-12T16:41:32.274Z">
<meta property="article:author" content="墨香">
<meta property="article:tag" content="AndroidOS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.codemx.cn/img/head.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.codemx.cn/2017/12/25/AndroidOS007-Broadcast2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>(()=>{
      const saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
      
      window.btf = {
        saveToLocal: saveToLocal,
        getScript: (url, attr = {}) => new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = url
          script.async = true
          script.onerror = reject
          script.onload = script.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            script.onload = script.onreadystatechange = null
            resolve()
          }

          Object.keys(attr).forEach(key => {
            script.setAttribute(key, attr[key])
          })

          document.head.appendChild(script)
        }),

        getCSS: (url, id = false) => new Promise((resolve, reject) => {
          const link = document.createElement('link')
          link.rel = 'stylesheet'
          link.href = url
          if (id) link.id = id
          link.onerror = reject
          link.onload = link.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            link.onload = link.onreadystatechange = null
            resolve()
          }
          document.head.appendChild(link)
        }),

        addGlobalFn: (key, fn, name = false, parent = window) => {
          const pjaxEnable = false
          if (!pjaxEnable && key.startsWith('pjax')) return

          const globalFn = parent.globalFn || {}
          const keyObj = globalFn[key] || {}
    
          if (name && keyObj[name]) return
    
          name = name || Object.keys(keyObj).length
          keyObj[name] = fn
          globalFn[key] = keyObj
          parent.globalFn = globalFn
        }
      }
    
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode
      
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Android系统源码分析--Broadcast发送',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-13 00:41:32'
}</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg" style="background-image: url(/img/bg.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img fixed" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="墨香博客"><span class="site-name">墨香博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Android系统源码分析--Broadcast发送</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2017-12-25T09:08:52.000Z" title="发表于 2017-12-25 17:08:52">2017-12-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-12T16:41:32.274Z" title="更新于 2024-07-13 00:41:32">2024-07-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AndroidOS/">AndroidOS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Android系统源码分析--Broadcast发送"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><blockquote>
<p>上一篇分析了Android系统中广播的注册和注销，这一篇我们继续分析发送广播的源码流程，广播的发送相对来说比较复杂，所以需要比较长的时间来看，如果你看懂了流程相对来说再研究流程中的细节就比较简单了。</p>
</blockquote>
<span id="more"></span>

<p>先看一张时序图，因为里面涉及到循环过程，代码中会提到，但是时序图没有绘制，所以需要注意一下。</p>
<p><img src="/images/AndroidOS/006Broadcast/sendBroadcast.jpg" alt="注册广播时序图"></p>
<h4 id="0、ContextImpl-sendBroadcast"><a href="#0、ContextImpl-sendBroadcast" class="headerlink" title="0、ContextImpl.sendBroadcast"></a>0、ContextImpl.sendBroadcast</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 发送广播</span></span><br><span class="line"><span class="comment">    * 步骤：</span></span><br><span class="line"><span class="comment">    * 1.广播发送者，即一个Activity组件或者一个Service组件，将一个特定类型的广播发送给AMS</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * 2.AMS接收到一个广播后，首先找到与这个广播对应的广播接收者，然后将它们添加到一个广播调度队列中，</span></span><br><span class="line"><span class="comment">    * 最后向AMS所运行在的先从的消息队列发送一个类型为BROADCAST_INTENT_MSG的消息，这时候对广播发送</span></span><br><span class="line"><span class="comment">    * 者来说，一个广播就发送完了。</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * 3.当发送到AMS所运行在的线程的消息队列中的BROADCAST_INTENT_MSG消息被处理时，AMS就会从广播调</span></span><br><span class="line"><span class="comment">    * 度队列中知道需要接受广播的接收者，并且将对应的广播发送给它们所运行在的应用进程。</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * 4.广播接收者所运行的应用程序接收到AMS发送过来的广播后，并不是直接将接收到的广播发送给广播接收</span></span><br><span class="line"><span class="comment">    * 者来处理，而是将接收到的广播封装成一个消息，并且发送到主线程的消息队列中。当找个消息被处理时，</span></span><br><span class="line"><span class="comment">    * 应用程序进程才会将它所描述的广播发给相应的广播接收者处理</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * 参考：</span></span><br><span class="line"><span class="comment">    * http://blog.csdn.net/houliang120/article/details/51607170</span></span><br><span class="line"><span class="comment">    * http://gityuan.com/2016/06/04/broadcast-receiver/</span></span><br><span class="line"><span class="comment">    * http://blog.csdn.net/windskier/article/details/7251742</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> intent The Intent to broadcast; all receivers matching this</span></span><br><span class="line"><span class="comment">    *               Intent will receive the broadcast.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendBroadcast</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           ...</span><br><span class="line">           <span class="comment">// 调用ActivityManagerProxy中的broadcastIntent，然后通过Binder调用ActivityManagerService</span></span><br><span class="line">           <span class="comment">// 中的broadcastIntent</span></span><br><span class="line">           ActivityManagerNative.getDefault().broadcastIntent(</span><br><span class="line">                   mMainThread.getApplicationThread(), intent, resolvedType, <span class="literal">null</span>,</span><br><span class="line">                   Activity.RESULT_OK, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, AppOpsManager.OP_NONE,</span><br><span class="line">                   <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">false</span>, getUserId());</span><br><span class="line">       &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>之前我们讲过调用ActivityManagerProxy的broadcastIntent方法，然后通过Binder调用ActivityManagerService中的对应方法。</p>
<h4 id="1、ActivityManagerProxy-broadcastIntent"><a href="#1、ActivityManagerProxy-broadcastIntent" class="headerlink" title="1、ActivityManagerProxy.broadcastIntent"></a>1、ActivityManagerProxy.broadcastIntent</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">broadcastIntent</span><span class="params">(IApplicationThread caller,</span></span><br><span class="line"><span class="params">                           Intent intent, String resolvedType, IIntentReceiver resultTo,</span></span><br><span class="line"><span class="params">                           <span class="type">int</span> resultCode, String resultData, Bundle map,</span></span><br><span class="line"><span class="params">                           String[] requiredPermissions, <span class="type">int</span> appOp, Bundle options, <span class="type">boolean</span> serialized,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> sticky, <span class="type">int</span> userId)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 通过Binder对象mRemote向AMS发送一个类型为BROADCAST_INTENT_TRANSACTION的进程间通信请求</span></span><br><span class="line">    mRemote.transact(BROADCAST_INTENT_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、ActivityManagerService-broadcastIntent"><a href="#2、ActivityManagerService-broadcastIntent" class="headerlink" title="2、ActivityManagerService.broadcastIntent"></a>2、ActivityManagerService.broadcastIntent</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送广播</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">broadcastIntent</span><span class="params">(IApplicationThread caller,</span></span><br><span class="line"><span class="params">                                 Intent intent, String resolvedType, IIntentReceiver resultTo,</span></span><br><span class="line"><span class="params">                                 <span class="type">int</span> resultCode, String resultData, Bundle resultExtras,</span></span><br><span class="line"><span class="params">                                 String[] requiredPermissions, <span class="type">int</span> appOp, Bundle bOptions,</span></span><br><span class="line"><span class="params">                                 <span class="type">boolean</span> serialized, <span class="type">boolean</span> sticky, <span class="type">int</span> userId)</span> &#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">&quot;broadcastIntent&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 验证广播的Intent是否合法，如果这个时候系统正在启动，还会验证intent所描述的广播是否只发送</span></span><br><span class="line">        <span class="comment">// 给动态注册的广播接收者。在系统的启动过程中，PMS可能还未启动，这种情况下，AMS是无法获取静态</span></span><br><span class="line">        <span class="comment">// 注册广播接收者的，因此，就禁止发送广播给静态注册的广播接收者</span></span><br><span class="line">        intent = verifyBroadcastLocked(intent);</span><br><span class="line">        <span class="comment">// 根据caller从缓存mLruProcesses中获取进程对象ProcessRecord</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ProcessRecord</span> <span class="variable">callerApp</span> <span class="operator">=</span> getRecordForAppLocked(caller);</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> broadcastIntentLocked(callerApp,</span><br><span class="line">                callerApp != <span class="literal">null</span> ? callerApp.info.packageName : <span class="literal">null</span>,</span><br><span class="line">                intent, resolvedType, resultTo, resultCode, resultData, resultExtras,</span><br><span class="line">                requiredPermissions, appOp, bOptions, serialized, sticky,</span><br><span class="line">                callingPid, callingUid, userId);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、ActivityManagerService-broadcastIntentLocked"><a href="#3、ActivityManagerService-broadcastIntentLocked" class="headerlink" title="3、ActivityManagerService.broadcastIntentLocked"></a>3、ActivityManagerService.broadcastIntentLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">broadcastIntentLocked</span><span class="params">(ProcessRecord callerApp,</span></span><br><span class="line"><span class="params">                                String callerPackage, Intent intent, String resolvedType,</span></span><br><span class="line"><span class="params">                                IIntentReceiver resultTo, <span class="type">int</span> resultCode, String resultData,</span></span><br><span class="line"><span class="params">                                Bundle resultExtras, String[] requiredPermissions, <span class="type">int</span> appOp, Bundle bOptions,</span></span><br><span class="line"><span class="params">                                <span class="type">boolean</span> ordered, <span class="type">boolean</span> sticky, <span class="type">int</span> callingPid, <span class="type">int</span> callingUid, <span class="type">int</span> userId)</span> &#123;</span><br><span class="line">    intent = <span class="keyword">new</span> <span class="title class_">Intent</span>(intent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// By default broadcasts do not go to stopped apps.</span></span><br><span class="line">    <span class="comment">// 增加下面flag，默认不发送广播到已经停止的app</span></span><br><span class="line">    intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have not finished booting, don&#x27;t allow this to launch new processes.</span></span><br><span class="line">    <span class="comment">// 如果该进程还没有完成启动，并且不是发送给启动升级的广播，则添只发送给已注册的广播接收者标签</span></span><br><span class="line">    <span class="keyword">if</span> (!mProcessesReady &amp;&amp; (intent.getFlags() &amp; Intent.FLAG_RECEIVER_BOOT_UPGRADE) == <span class="number">0</span>) &#123;</span><br><span class="line">        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);<span class="comment">// 只发给注册的receiver</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前发送广播应用所在用户的userId</span></span><br><span class="line">    <span class="comment">// 解释：</span></span><br><span class="line">    <span class="comment">// 7.1.1系统有多用户登录，就像电脑上的主用户和访客模式一样，可以设置多个用户，每个用户有一个id，</span></span><br><span class="line">    <span class="comment">// 有些广播需要多个用户都要接收，比如时区变化这些，是同步的，每个用户都要变化。这里一般是我们</span></span><br><span class="line">    <span class="comment">// 当前登录的用户id</span></span><br><span class="line">    userId = mUserController.handleIncomingUser(callingPid, callingUid, userId, <span class="literal">true</span>,</span><br><span class="line">            ALLOW_NON_FULL, <span class="string">&quot;broadcast&quot;</span>, callerPackage);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure that the user who is receiving this broadcast is running.</span></span><br><span class="line">    <span class="comment">// If not, we will just skip it. Make an exception for shutdown broadcasts</span></span><br><span class="line">    <span class="comment">// and upgrade steps.</span></span><br><span class="line">    <span class="keyword">if</span> (userId != UserHandle.USER_ALL &amp;&amp; !mUserController.isUserRunningLocked(userId, <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.BROADCAST_FAILED_USER_STOPPED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verify that protected broadcasts are only being sent by system code,</span></span><br><span class="line">    <span class="comment">// and that system code is only sending protected broadcasts.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> intent.getAction();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> isProtectedBroadcast;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 验证是不是受保护的广播（是不是系统广播）</span></span><br><span class="line">        isProtectedBroadcast = AppGlobals.getPackageManager().isProtectedBroadcast(action);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ActivityManager.BROADCAST_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是不是系统调用</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> isCallerSystem;</span><br><span class="line">    <span class="keyword">switch</span> (UserHandle.getAppId(callingUid)) &#123;</span><br><span class="line">        <span class="keyword">case</span> Process.ROOT_UID:</span><br><span class="line">        <span class="keyword">case</span> Process.SYSTEM_UID:</span><br><span class="line">        <span class="keyword">case</span> Process.PHONE_UID:</span><br><span class="line">        <span class="keyword">case</span> Process.BLUETOOTH_UID:</span><br><span class="line">        <span class="keyword">case</span> Process.NFC_UID:</span><br><span class="line">            isCallerSystem = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            isCallerSystem = (callerApp != <span class="literal">null</span>) &amp;&amp; callerApp.persistent;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First line security check before anything else: stop non-system apps from</span></span><br><span class="line">    <span class="comment">// sending protected broadcasts.</span></span><br><span class="line">    <span class="keyword">if</span> (!isCallerSystem) &#123;<span class="comment">// 不是系统发送的广播</span></span><br><span class="line">        <span class="keyword">if</span> (isProtectedBroadcast) &#123;<span class="comment">// 非系统进程发送受保护广播抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)</span><br><span class="line">                || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) &#123;</span><br><span class="line">            <span class="comment">// 如果是配置小部件或者升级小部件的广播</span></span><br><span class="line">            <span class="comment">// Special case for compatibility: we don&#x27;t want apps to send this,</span></span><br><span class="line">            <span class="comment">// but historically it has not been protected and apps may be using it</span></span><br><span class="line">            <span class="comment">// to poke their own app widget.  So, instead of making it protected,</span></span><br><span class="line">            <span class="comment">// just limit it to the caller.</span></span><br><span class="line">            <span class="keyword">if</span> (callerPackage == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(msg);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (intent.getComponent() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// They are good enough to send to an explicit component...  verify</span></span><br><span class="line">                <span class="comment">// it is being sent to the calling app.</span></span><br><span class="line">                <span class="keyword">if</span> (!intent.getComponent().getPackageName().equals(</span><br><span class="line">                        callerPackage)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Limit broadcast to their own package.</span></span><br><span class="line">                <span class="comment">// 限制发送广播给自己包里</span></span><br><span class="line">                intent.setPackage(callerPackage);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面主要是针对系统广播的处理</span></span><br><span class="line">    <span class="keyword">if</span> (action != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_UID_REMOVED:<span class="comment">// 移除uid</span></span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_PACKAGE_REMOVED:<span class="comment">// 卸载应用</span></span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_PACKAGE_CHANGED:<span class="comment">// 应用更改，比如：停用，启动等</span></span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:<span class="comment">// 外部应用不可用，比如安装到sd卡的应用，卸载了sd卡</span></span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:<span class="comment">// 外部应用可用</span></span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_PACKAGES_SUSPENDED:<span class="comment">// 暂停应用</span></span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_PACKAGES_UNSUSPENDED:<span class="comment">// 应用可用</span></span><br><span class="line">                <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">                    <span class="keyword">case</span> Intent.ACTION_UID_REMOVED:<span class="comment">// 移除系统userId（删除一个用户）</span></span><br><span class="line">                        ...</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:<span class="comment">// 外部应用不可用，一般是卸载SD卡</span></span><br><span class="line">                        ...</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:<span class="comment">// 外部应用可用，一般是插入SD卡</span></span><br><span class="line">                        ...</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Intent.ACTION_PACKAGE_REMOVED:<span class="comment">// 卸载</span></span><br><span class="line">                    <span class="keyword">case</span> Intent.ACTION_PACKAGE_CHANGED:<span class="comment">// 更新</span></span><br><span class="line">                        ...</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Intent.ACTION_PACKAGES_SUSPENDED:</span><br><span class="line">                    <span class="keyword">case</span> Intent.ACTION_PACKAGES_UNSUSPENDED:</span><br><span class="line">                        ...</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_PACKAGE_REPLACED: &#123;<span class="comment">// 升级应用</span></span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_PACKAGE_ADDED: &#123;<span class="comment">// 安装应用</span></span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_PACKAGE_DATA_CLEARED: &#123;<span class="comment">// 清理应用数据</span></span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_TIMEZONE_CHANGED:<span class="comment">// 时区改变</span></span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_TIME_CHANGED:<span class="comment">// 时间改变</span></span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_CLEAR_DNS_CACHE:<span class="comment">// 清理DNS缓存</span></span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Proxy.PROXY_CHANGE_ACTION:<span class="comment">// 代理改变</span></span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> android.hardware.Camera.ACTION_NEW_PICTURE:<span class="comment">// 新照片</span></span><br><span class="line">            <span class="keyword">case</span> android.hardware.Camera.ACTION_NEW_VIDEO:<span class="comment">// 新视频</span></span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">return</span> ActivityManager.BROADCAST_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add to the sticky list if requested.</span></span><br><span class="line">    <span class="keyword">if</span> (sticky) &#123;<span class="comment">// 判断是否是粘性广播，如果是，AMS就需要保存这个广播，以便后面注册要接收此类型广播的接收者可以获得这个广播</span></span><br><span class="line">        <span class="comment">// 检查粘性广播是否申请了权限</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (requiredPermissions != <span class="literal">null</span> &amp;&amp; requiredPermissions.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sticky广播不能指定目标组件</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// We use userId directly here, since the &quot;all&quot; target is maintained（维护）</span></span><br><span class="line">        <span class="comment">// as a separate set of sticky broadcasts.</span></span><br><span class="line">        <span class="keyword">if</span> (userId != UserHandle.USER_ALL) &#123;<span class="comment">// 不是发送给所有用户的广播</span></span><br><span class="line">            <span class="comment">// But first, if this is not a broadcast to all users, then</span></span><br><span class="line">            <span class="comment">// make sure it doesn&#x27;t conflict（冲突） with an existing broadcast to</span></span><br><span class="line">            <span class="comment">// all users.</span></span><br><span class="line">            ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(</span><br><span class="line">                    UserHandle.USER_ALL);</span><br><span class="line">            ...<span class="comment">// 检查是否和存在的发给所有用户的粘性广播一样的广播</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在AMS中所有的粘性广播都保存在一个列表中，这些列表最终保存在AMS的成员变量mStickyBroadcasts</span></span><br><span class="line">        <span class="comment">// 所描述的一个HashMap中，并且以它们的广播类型为关键字</span></span><br><span class="line">        <span class="comment">// 首先检查mStickyBroadcasts是否有改用户的粘性广播列表</span></span><br><span class="line">        ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(userId);</span><br><span class="line">        <span class="comment">// 该广播列表中没有该用户的stick广播列表</span></span><br><span class="line">        <span class="keyword">if</span> (stickies == <span class="literal">null</span>) &#123;</span><br><span class="line">            stickies = <span class="keyword">new</span> <span class="title class_">ArrayMap</span>&lt;&gt;();</span><br><span class="line">            mStickyBroadcasts.put(userId, stickies);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取注册广播的Action对应的粘性广播的Intent列表</span></span><br><span class="line">        ArrayList&lt;Intent&gt; list = stickies.get(intent.getAction());</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;<span class="comment">// 如果为空</span></span><br><span class="line">            list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">// 创建一个列表</span></span><br><span class="line">            stickies.put(intent.getAction(), list);<span class="comment">// 以action为键保存该列表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取该action对应粘性广播Intent列表的个数</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">stickiesCount</span> <span class="operator">=</span> list.size();</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="comment">// 检查在粘性广播列表中是否保存了一个与参数Intent一致的广播。如果存在直接替换，否则将参数</span></span><br><span class="line">        <span class="comment">// Intent描述的广播添加到粘性广播列表list中</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; stickiesCount; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intent.filterEquals(list.get(i))) &#123;</span><br><span class="line">                <span class="comment">// This sticky already exists, replace it.</span></span><br><span class="line">                list.set(i, <span class="keyword">new</span> <span class="title class_">Intent</span>(intent));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= stickiesCount) &#123;<span class="comment">// 如果该列表中不存在该粘性广播的Intent加入进去</span></span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Intent</span>(intent));</span><br><span class="line">            <span class="comment">// 我们看到粘性广播放在了list中，而list以action为键放置在了stickies中，而stickies</span></span><br><span class="line">            <span class="comment">// 又以userId为键放在了mStickyBroadcasts中，因此mStickyBroadcasts保存了设备中所有</span></span><br><span class="line">            <span class="comment">// 用户粘性广播的Intent</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] users;</span><br><span class="line">    <span class="keyword">if</span> (userId == UserHandle.USER_ALL) &#123;<span class="comment">// 发送广播给全部用户</span></span><br><span class="line">        <span class="comment">// Caller wants broadcast to go to all started users.</span></span><br><span class="line">        <span class="comment">// 获取所有已启动用户的列表</span></span><br><span class="line">        users = mUserController.getStartedUserArrayLocked();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 发送广播给指定用户</span></span><br><span class="line">        <span class="comment">// Caller wants broadcast to go to one specific user.</span></span><br><span class="line">        users = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;userId&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Figure out who all will receive this broadcast.</span></span><br><span class="line">    <span class="type">List</span> <span class="variable">receivers</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">// 静态注册接收者</span></span><br><span class="line">    List&lt;BroadcastFilter&gt; registeredReceivers = <span class="literal">null</span>;<span class="comment">// 动态注册接收者</span></span><br><span class="line">    <span class="comment">// Need to resolve the intent to interested receivers...</span></span><br><span class="line">    <span class="keyword">if</span> ((intent.getFlags() &amp; Intent.FLAG_RECEIVER_REGISTERED_ONLY)</span><br><span class="line">            == <span class="number">0</span>) &#123;<span class="comment">// 如果当前的广播Intent没有指定FLAG_RECEIVER_REGISTERED_ONLY标记，也就是允许静态注册</span></span><br><span class="line">        <span class="comment">// 允许静态注册的Intent，需要从PMS中去查询对应的广播接收者</span></span><br><span class="line">        receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果参数intent没有指定广播接收者的组件名，说明是发送给所有已注册并且要接收该广播的接收者的</span></span><br><span class="line">    <span class="keyword">if</span> (intent.getComponent() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (userId == UserHandle.USER_ALL &amp;&amp; callingUid == Process.SHELL_UID) &#123;</span><br><span class="line">            <span class="comment">// Query one target user at a time, excluding shell-restricted users</span></span><br><span class="line">            <span class="comment">// 查找每一个用户的广播注册者</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; users.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mUserController.hasUserRestriction(</span><br><span class="line">                        UserManager.DISALLOW_DEBUGGING_FEATURES, users[i])) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// registeredReceiver快结束前将注册的BroadcastFilter放入mReceiverResolver中</span></span><br><span class="line">                <span class="comment">// 里面包含了对应的动态注册的广播接收者</span></span><br><span class="line">                List&lt;BroadcastFilter&gt; registeredReceiversForUser =</span><br><span class="line">                        mReceiverResolver.queryIntent(intent,</span><br><span class="line">                                resolvedType, <span class="literal">false</span>, users[i]);</span><br><span class="line">                <span class="keyword">if</span> (registeredReceivers == <span class="literal">null</span>) &#123;</span><br><span class="line">                    registeredReceivers = registeredReceiversForUser;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (registeredReceiversForUser != <span class="literal">null</span>) &#123;</span><br><span class="line">                    registeredReceivers.addAll(registeredReceiversForUser);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 查找当前用户的所有广播接收者</span></span><br><span class="line">            <span class="comment">// 查询所有动态注册广播接收者</span></span><br><span class="line">            registeredReceivers = mReceiverResolver.queryIntent(intent,</span><br><span class="line">                    resolvedType, <span class="literal">false</span>, userId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 由于AMS是通过消息机制将接收到的广播发送给目标广播接收者的，因此可能会出现一种情况：上次接收</span></span><br><span class="line">    <span class="comment">// 的广播还没有来得及发送给广播接收者，又马上接收到一个同样的广播，在这种情况下，如果现在接收的</span></span><br><span class="line">    <span class="comment">// 广播标志位FLAG_RECEIVER_REPLACE_PENDING等于1，那么AMS就会用新的广播代替旧的广播。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">replacePending</span> <span class="operator">=</span></span><br><span class="line">            (intent.getFlags() &amp; Intent.FLAG_RECEIVER_REPLACE_PENDING) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态广播接收者个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">NR</span> <span class="operator">=</span> registeredReceivers != <span class="literal">null</span> ? registeredReceivers.size() : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 处理无序广播并且存在动态接收者，首先将当前发送的广播，即参数Intent所描述的对象转发给这些动态</span></span><br><span class="line">    <span class="comment">// 注册的目标广播接收者，然后转发给静态广播接收者</span></span><br><span class="line">    <span class="keyword">if</span> (!ordered &amp;&amp; NR &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 根据intent查找对应的广播队列（前台优先级队列还是后台优先级队列），创建BroadcastRecord</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">BroadcastQueue</span> <span class="variable">queue</span> <span class="operator">=</span> broadcastQueueForIntent(intent);</span><br><span class="line">        <span class="comment">// 将参数intent所描述的广播以及动态注册的目标广播接收者封装成一个BroadcastRecord对象r，</span></span><br><span class="line">        <span class="comment">// 用来描述AMS要执行的一个广播转发任务</span></span><br><span class="line">        <span class="type">BroadcastRecord</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BroadcastRecord</span>(queue, intent, callerApp,</span><br><span class="line">                callerPackage, callingPid, callingUid, resolvedType, requiredPermissions,</span><br><span class="line">                appOp, brOptions, registeredReceivers, resultTo, resultCode, resultData,</span><br><span class="line">                resultExtras, ordered, sticky, <span class="literal">false</span>, userId);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 在BroadcastQueue中等待发送广播中搜索是否有相同的BroadcastRecord并且是否替换</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">replaced</span> <span class="operator">=</span> replacePending &amp;&amp; queue.replaceParallelBroadcastLocked(r);</span><br><span class="line">        <span class="keyword">if</span> (!replaced) &#123;</span><br><span class="line">            <span class="comment">// 如果不需要替换则插入到BroadcastQueue中，并推动一次广播发送</span></span><br><span class="line">            <span class="comment">// ------------------!!!重要!!!-------------这里如果是非有序广播，那就都是动态广播接收者</span></span><br><span class="line">            <span class="comment">// 也就是说动态广播接收者都放在了BroadcastQueue的mParallelBroadcasts中</span></span><br><span class="line">            queue.enqueueParallelBroadcastLocked(r);</span><br><span class="line">            queue.scheduleBroadcastsLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        registeredReceivers = <span class="literal">null</span>;</span><br><span class="line">        NR = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge into one list.动态广播registeredReceivers和静态广播receivers合并</span></span><br><span class="line">    <span class="comment">// 如果是order广播，动态接收者和静态的接收者合并到一个队列里面进行处理，也就是说order广播下，</span></span><br><span class="line">    <span class="comment">// 所有的接收者（静态和动态）处理方式都是一样的（后面会分析到，都是串行化处理的）。</span></span><br><span class="line">    <span class="comment">// 还有就是对于静态的接收者而言，始终是和order广播的处理方式是一样的，也就是说静态的接收者</span></span><br><span class="line">    <span class="comment">// 只有order模式（串行化接收）。</span></span><br><span class="line">    <span class="comment">// 在合并过程中，如果一个动态注册的广播接收者和一个静态注册的目标广播接收者的优先级相同，那么</span></span><br><span class="line">    <span class="comment">// 动态注册的目标接收者会排在静态注册的目标广播接收者前面，即动态注册的目标广播接收者会优先于</span></span><br><span class="line">    <span class="comment">// 静态注册的广播接收者接受有序广播</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ir</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (receivers != <span class="literal">null</span>) &#123;<span class="comment">// order广播（静态广播）</span></span><br><span class="line">        <span class="comment">// 对于ACTION_PACKAGE_ADDED广播而言，如果是自己被add了，那么这个广播只能别人收到，</span></span><br><span class="line">        <span class="comment">// 自己即使注册了这个静态广播也接收不到，注释上说是担心有些应用一安装就接收自己的PACKAGE_ADDED</span></span><br><span class="line">        <span class="comment">// 广播，然后就启动了。简言之，应用永远接收不到自己的PACKAGE_ADDED广播。</span></span><br><span class="line">        String skipPackages[] = <span class="literal">null</span>;<span class="comment">// 需要跳过的广播</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并中...</span></span><br><span class="line">        <span class="comment">// 下面这一段代码是典型的有序链表的合并操作，合并的依据是接收者的priority值，这里需要注意的一点</span></span><br><span class="line">        <span class="comment">// 是动态广播接收器注册的时候一般都没有指定priority，默认值是0，具体实现好像有点像归并排序的意思，</span></span><br><span class="line">        <span class="comment">// 而且是从后向前进行的归并，因此priority越小，在链表中的位置就越靠前，后面处理的时候也就越先处理。</span></span><br><span class="line">        <span class="comment">// 走完这里所有的静态接收者和order模式下的动态接收者都已经被合并到了receivers链表里面。</span></span><br><span class="line">        <span class="comment">// 合并以后在receivers链表里面静态接收者对应ResolveInfo对象，order模式下的动态接收者对应的</span></span><br><span class="line">        <span class="comment">// 是BroadcastFilter对象。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">NT</span> <span class="operator">=</span> receivers != <span class="literal">null</span> ? receivers.size() : <span class="number">0</span>;<span class="comment">// 静态注册广播接收者</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">it</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ResolveInfo</span> <span class="variable">curt</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">// 静态接收者</span></span><br><span class="line">        <span class="type">BroadcastFilter</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">// 动态接收者</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对于无序广播来说，静态注册的广播接收者全部保存在列表receivers中，而对于有序广播来说，静态</span></span><br><span class="line">    <span class="comment">// 注册和动态注册的目标广播接收者全部保存在receivers列表中</span></span><br><span class="line">    <span class="comment">// 合并中...</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以看出，是在合并入receiver后统一发送BroadcastQueue.scheduleBroadcastsLocked</span></span><br><span class="line">    <span class="keyword">if</span> ((receivers != <span class="literal">null</span> &amp;&amp; receivers.size() &gt; <span class="number">0</span>)</span><br><span class="line">            || resultTo != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">BroadcastQueue</span> <span class="variable">queue</span> <span class="operator">=</span> broadcastQueueForIntent(intent);</span><br><span class="line">        <span class="comment">// 将剩余的其他目标广播接收者封装成另外的一个BroadcastRecord对象，用来描述AMS要执行的另</span></span><br><span class="line">        <span class="comment">// 一个广播转发任务，兵器添加到AMS内部的有序广播调用队列中</span></span><br><span class="line">        <span class="type">BroadcastRecord</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BroadcastRecord</span>(queue, intent, callerApp,</span><br><span class="line">                callerPackage, callingPid, callingUid, resolvedType,</span><br><span class="line">                requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode,</span><br><span class="line">                resultData, resultExtras, ordered, sticky, <span class="literal">false</span>, userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在BroadcastQueue中等待发送广播中搜索是否有相同的BroadcastRecord并且是否替换</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">replaced</span> <span class="operator">=</span> replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r);</span><br><span class="line">        <span class="keyword">if</span> (!replaced) &#123;<span class="comment">// 存在需要AMS的有序广播调用队列中增加新的额广播任务</span></span><br><span class="line">            <span class="comment">// ---------!!!重要!!!----------包含动态和静态接收者</span></span><br><span class="line">            <span class="comment">// 也就是说静态广播都放在BroadcastQueue的mOrderedBroadcasts中，这里也有orderd动态广播</span></span><br><span class="line">            queue.enqueueOrderedBroadcastLocked(r);</span><br><span class="line">            <span class="comment">// 执行发送广播</span></span><br><span class="line">            queue.scheduleBroadcastsLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// There was nobody interested in the broadcast, but we still want to record</span></span><br><span class="line">        <span class="comment">// that it happened.</span></span><br><span class="line">        <span class="keyword">if</span> (intent.getComponent() == <span class="literal">null</span> &amp;&amp; intent.getPackage() == <span class="literal">null</span></span><br><span class="line">                &amp;&amp; (intent.getFlags() &amp; Intent.FLAG_RECEIVER_REGISTERED_ONLY) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// This was an implicit broadcast... let&#x27;s record it for posterity.</span></span><br><span class="line">            addBroadcastStatLocked(intent.getAction(), callerPackage, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ActivityManager.BROADCAST_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里代码比较多，简单解释一下，首先是判断是不是系统广播，也就是switch语句中的部分，这部分的广播是系统发出的，根据不同广播做出不同的处理，系统广播我们可以接收但是不能发送，只能由系统发出，详细的不再解释，自己可以看看；然后是sticky广播的处理；然后是静态广播和动态广播的处理，在动态广播和静态广播处理中，先处理动态广播接收者，再处理静态广播接收者，因此动态广播接收者先收到广播，然后是静态广播接收者，动态广播和静态广播接收者都会通过调用BroadcastQueue.scheduleBroadcastsLocked方法来发送广播，在看这个代码之前先看一下时序图中的第四步。</p>
<h4 id="4、AMS-broadcastQueueForIntent"><a href="#4、AMS-broadcastQueueForIntent" class="headerlink" title="4、AMS.broadcastQueueForIntent"></a>4、AMS.broadcastQueueForIntent</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据Intent所带标签判断接收者是以前台优先级还是后台优先级运行，前台接收者优先级超时时间较短</span></span><br><span class="line"><span class="comment">// 正常是后台优先级运行，并且不会被提升到前台优先级</span></span><br><span class="line">BroadcastQueue <span class="title function_">broadcastQueueForIntent</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">isFg</span> <span class="operator">=</span> (intent.getFlags() &amp; Intent.FLAG_RECEIVER_FOREGROUND) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (isFg) ? mFgBroadcastQueue : mBgBroadcastQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要是根据Intent中的标签在判断是接收者是后台优先级还是前台优先级，关于这两个概念看上面代码中注释的内容。</p>
<h4 id="5、BroadcastQueue-scheduleBroadcastsLocked"><a href="#5、BroadcastQueue-scheduleBroadcastsLocked" class="headerlink" title="5、BroadcastQueue.scheduleBroadcastsLocked"></a>5、BroadcastQueue.scheduleBroadcastsLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 驱动广播，所有广播都应该从这里走，然后会到processNextBroadcast</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduleBroadcastsLocked</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// mBroadcastsScheduled用来描述AMS是否已经向它所运行在的线程的消息队列发送了一个类型为</span></span><br><span class="line">    <span class="comment">// BROADCAST_INTENT_MSG的消息。AMS就是通过这个BROADCAST_INTENT_MSG消息类调度保存在无</span></span><br><span class="line">    <span class="comment">// 序广播调度队列mParallelBroadcasts和有序广播调度队列mOrderedBroadcasts中的广播转发任务的</span></span><br><span class="line">    <span class="keyword">if</span> (mBroadcastsScheduled) &#123;<span class="comment">// 如果true说明消息队列已经存在一个类型为BROADCAST_INTENT_MSG的消息了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 虽然这里只发送了发送广播的消息，但是这一步执行完之后就已经标记广播发送了，因此可以看出广播发送和接</span></span><br><span class="line">    <span class="comment">// 受是异步的，即广播发送者将一个广播发送给AMS后，不会等待AMS将这个广播转发给广播接收者处理</span></span><br><span class="line">    mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, <span class="built_in">this</span>));</span><br><span class="line">    mBroadcastsScheduled = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>广播中大多数内容的处理是在BroadcastQueue类中，上面有个mBroadcastsScheduled参数，如果为ture则阻止继续执行，那么我们看到下面发完消息后会将其设置为true，我们接着看哪里将其执行为false的，</p>
<h4 id="6、BroadcastQueue-processNextBroadcast"><a href="#6、BroadcastQueue-processNextBroadcast" class="headerlink" title="6、BroadcastQueue.processNextBroadcast"></a>6、BroadcastQueue.processNextBroadcast</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 广播的核心部分，参数fromMsg是用来描述AMS类的成员函数processNextBroadcast是否是用来处理类型为</span></span><br><span class="line"><span class="comment">// BROADCAST_INTENT_MSG的消息的</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">processNextBroadcast</span><span class="params">(<span class="type">boolean</span> fromMsg)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mService) &#123;</span><br><span class="line">        BroadcastRecord r;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fromMsg) &#123;<span class="comment">// 从msg过来的时候为true</span></span><br><span class="line">            <span class="comment">// 前面说到，如果消息队列里面有BROADCAST_INTENT_MSG消息，该标记为true，</span></span><br><span class="line">            <span class="comment">// 阻止新的消息加入队列，这里开始处理这个消息的时候，将mBroadcastsScheduled变量设置为false，</span></span><br><span class="line">            <span class="comment">// 开始允许新的消息加入。</span></span><br><span class="line">            mBroadcastsScheduled = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无序广播之间不存在相互等待，这里处理的是所有非order的动态广播</span></span><br><span class="line">        <span class="comment">// 处理保存在无序广播调度队列mParallelBroadcasts中的广播发送任务，即把保存在无序广播调度</span></span><br><span class="line">        <span class="comment">// 队列mParallelBroadcasts中的广播发送给它的目标广播接收者处理</span></span><br><span class="line">        <span class="keyword">while</span> (mParallelBroadcasts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 首先保存无序广播调度队列mParallelBroadcasts中的每一个BroadcastRecord对象</span></span><br><span class="line">            r = mParallelBroadcasts.remove(<span class="number">0</span>);</span><br><span class="line">            r.dispatchTime = SystemClock.uptimeMillis();</span><br><span class="line">            r.dispatchClockTime = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// 调用deliverToRegisteredReceiverLocked向所有的receivers发送广播</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> r.receivers.size();</span><br><span class="line">            <span class="comment">// 将它所描述的每一个无序广播发送给每一个广播接收者</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> r.receivers.get(i);</span><br><span class="line">                deliverToRegisteredReceiverLocked(r, (BroadcastFilter) target, <span class="literal">false</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">            addBroadcastToHistoryLocked(r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 接下来处理保存在有序广播调度队列mPendingBroadcast中的广播转发任务。有前面可知，有序广播</span></span><br><span class="line">        <span class="comment">// 调度队列mOrderedBroadcast描述的目标广播接收者有可能是静态注册的，而这些静态注册的目标广</span></span><br><span class="line">        <span class="comment">// 播接收者可能还没有启动起来，因此AMS将一个广播发送给它们处理时，首先将它们启动起来。事实上，</span></span><br><span class="line">        <span class="comment">// AMS只需要将他们所运行在的进程启动起来就可以了，因为当这些进程接收到AMS发送的广播后，就会</span></span><br><span class="line">        <span class="comment">// 主动将目标广播接收者启动起来</span></span><br><span class="line">        <span class="comment">// mPendingBroadcast对象是用来描述一个正在等待静态注册的目标广播接收者启动起来的广播转发任务的</span></span><br><span class="line">        <span class="keyword">if</span> (mPendingBroadcast != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">boolean</span> isDead;</span><br><span class="line">            <span class="keyword">synchronized</span> (mService.mPidsSelfLocked) &#123;</span><br><span class="line">                <span class="comment">// 检查目标广播接收者所在进程是否已经启动</span></span><br><span class="line">                <span class="type">ProcessRecord</span> <span class="variable">proc</span> <span class="operator">=</span> mService.mPidsSelfLocked.get(mPendingBroadcast.curApp.pid);</span><br><span class="line">                isDead = proc == <span class="literal">null</span> || proc.crashing;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isDead) &#123;<span class="comment">// 如果正在启动，等待</span></span><br><span class="line">                <span class="comment">// It&#x27;s still alive, so keep waiting</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 已经启动准备发送广播</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">looped</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逐条处理有序广播列表mOrderedBroadcasts中的BroadcastRecord</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 判断有序广播调度队列mOrderedBroadcasts是否还有需要处理的广播</span></span><br><span class="line">            <span class="keyword">if</span> (mOrderedBroadcasts.size() == <span class="number">0</span>) &#123;<span class="comment">// 没有，说明调度队列中的广播已经处理完成</span></span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有处理完成，取出下一个马上要处理的广播BroadcastRecord</span></span><br><span class="line">            r = mOrderedBroadcasts.get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">forceReceive</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取广播转发任务的目标广播接收者的个数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">numReceivers</span> <span class="operator">=</span> (r.receivers != <span class="literal">null</span>) ? r.receivers.size() : <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 检查前一个目标广播接收者是否在规定的时间内处理完成AMS给它发送的一个有序广播。AMS处理</span></span><br><span class="line">            <span class="comment">// BroadcastRecord对象r所描述的一个广播转发任务时，会将当前时间记录在这个BroadcastRecord</span></span><br><span class="line">            <span class="comment">// 对象中，如果这个广播任务不能在（2*BROADCAST_TIMEOUT*numReceivers）毫秒内完成，即它的目</span></span><br><span class="line">            <span class="comment">// 标广播接收者不能在（2*BROADCAST_TIMEOUT*numReceivers）毫秒内完成AMS给它们发送的一个有</span></span><br><span class="line">            <span class="comment">// 序广播，那么会调用broadcastTimeoutLocked函数来强制结束这个广播转发任务，</span></span><br><span class="line">            <span class="keyword">if</span> (mService.mProcessesReady &amp;&amp; r.dispatchTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">                <span class="keyword">if</span> ((numReceivers &gt; <span class="number">0</span>) &amp;&amp;</span><br><span class="line">                        (now &gt; r.dispatchTime + (<span class="number">2</span> * mTimeoutPeriod * numReceivers))) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="comment">// 出现超时，强制结束</span></span><br><span class="line">                    broadcastTimeoutLocked(<span class="literal">false</span>); <span class="comment">// forcibly finish this broadcast</span></span><br><span class="line">                    <span class="comment">// 重置参数，继续处理有序广播调度队列mOrderedBroadcasts的下一个广播转发任务</span></span><br><span class="line">                    forceReceive = <span class="literal">true</span>;</span><br><span class="line">                    r.state = BroadcastRecord.IDLE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测广播转发任务是否正在处理中，即AMS正在将一个有序广播转发给它的前一个目标广播接收处理者，</span></span><br><span class="line">            <span class="comment">// 如果是，AMS就会等待这个目标广播接收者处理完该有序广播，然后再转发给下一个广播接收者处理</span></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 表示广播已经向所有的receiver发送结束或者中途被取消, 如果r.resultAbort为true，会停止处理</span></span><br><span class="line">            <span class="comment">// 当前正在发送的BroadcastRecord，这样优先级比较低的接收者也就收不到这个广播了</span></span><br><span class="line">            <span class="comment">// 检查BroadcastRecord对象r所描述的广播转发任务是否已经处理完成，或者是否已经被强制结束了。</span></span><br><span class="line">            <span class="comment">// 如果是，那么调用函数cancelBroadcastTimeoutLocked来删除前面发送到AMS所运行在的线程的消息</span></span><br><span class="line">            <span class="comment">// 队列中的一个BROADCAST_TIMEOUT_MSG消息,表示BroadcastRecord对象r所描述的广播转发任务已经</span></span><br><span class="line">            <span class="comment">// 在规定时间内处理完成了。接下来就讲改广播BroadcastRecord对象从队列中删除，然后赋值为null</span></span><br><span class="line">            <span class="keyword">if</span> (r.receivers == <span class="literal">null</span> || r.nextReceiver &gt;= numReceivers</span><br><span class="line">                    || r.resultAbort || forceReceive) &#123;</span><br><span class="line">                <span class="comment">// No more receivers for this broadcast!  Send the final</span></span><br><span class="line">                <span class="comment">// result if requested...</span></span><br><span class="line">                <span class="keyword">if</span> (r.resultTo != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        ...</span><br><span class="line">                        performReceiveLocked(r.callerApp, r.resultTo,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">Intent</span>(r.intent), r.resultCode,</span><br><span class="line">                                r.resultData, r.resultExtras, <span class="literal">false</span>, <span class="literal">false</span>, r.userId);</span><br><span class="line">                        <span class="comment">// Set this to null so that the reference</span></span><br><span class="line">                        <span class="comment">// (local and remote) isn&#x27;t kept in the mBroadcastHistory.</span></span><br><span class="line">                        r.resultTo = <span class="literal">null</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        ...    </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">// ... and on to the next...</span></span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">// BroadcastRecord处理完移除</span></span><br><span class="line">                mOrderedBroadcasts.remove(<span class="number">0</span>);</span><br><span class="line">                r = <span class="literal">null</span>;</span><br><span class="line">                looped = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (r == <span class="literal">null</span>);<span class="comment">// 如果第一次取出的r不为空，则退出循环</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the next receiver...（获取下一个将要处理的广播接收者在其列表中的位置）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">recIdx</span> <span class="operator">=</span> r.nextReceiver++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Keep track of when this receiver started, and make sure there</span></span><br><span class="line">        <span class="comment">// is a timeout message pending to kill it if need be.</span></span><br><span class="line">        <span class="comment">// 保存当前时间，</span></span><br><span class="line">        r.receiverTime = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (recIdx == <span class="number">0</span>) &#123;<span class="comment">// 表示第一个开始处理的接收者，也就是BroadcastRecord对象r所描述的广播任务刚被处理</span></span><br><span class="line">            <span class="comment">// 接收者开始处理的时间戳，也就是这个接收者开始处理了，要记录开始时间来计算是否超过超时时间</span></span><br><span class="line">            <span class="comment">// 也就是说这是BroadcastRecord中第一个接收者开始被处理的时间戳，也就是上面BroadcastRecord</span></span><br><span class="line">            <span class="comment">// 超时的起点，可以看到上面超时比较的时候用的就是r.dispatchTime</span></span><br><span class="line">            r.dispatchTime = r.receiverTime;</span><br><span class="line">            r.dispatchClockTime = System.currentTimeMillis();</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查AMS是否已经向它所在的线程的消息队列发送了类型为BROADCAST_TIMEOUT_MSG的消息，如果没有发送，</span></span><br><span class="line">        <span class="comment">// 那么会调用setBroadcastTimeoutLocked函数向这个线程发送一个类型为setBroadcastTimeoutLocked</span></span><br><span class="line">        <span class="comment">// 的消息，并且制定在timeoutTime毫秒后处理。上面指定了r.receiverTime为当前时间表示AMS将一个有序</span></span><br><span class="line">        <span class="comment">// 广播发送给BroadcastRecord对象r所描述的广播转发任务的下一个目标广播接收者处理的时间。如果这个</span></span><br><span class="line">        <span class="comment">// 广播接收者不能再timeoutTime之内完成这个有序广播，AMS就会任务它超时。</span></span><br><span class="line">        <span class="keyword">if</span> (!mPendingBroadcastTimeoutMessage) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">timeoutTime</span> <span class="operator">=</span> r.receiverTime + mTimeoutPeriod;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 设置超时，传入参数是r.receiverTime + mTimeoutPeriod，也就是开始时间加上超时时间</span></span><br><span class="line">            <span class="comment">// mTimeoutPeriod，mTimeoutPeriod初始化是在BroadcastQueue初始化的时候传入的，</span></span><br><span class="line">            <span class="comment">// 也就是在AMS（AMS构造函数中）中初始化mFgBroadcastQueue和mBgBroadcastQueue时传入的</span></span><br><span class="line">            <span class="comment">// BROADCAST_FG_TIMEOUT = 10 * 1000和BROADCAST_BG_TIMEOUT = 60 * 1000，</span></span><br><span class="line">            <span class="comment">// 这里开始埋了ANR的雷</span></span><br><span class="line">            setBroadcastTimeoutLocked(timeoutTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上面分析的时候对于BroadcastRecord.receivers里面包含两种receiver接收者：order广播下的</span></span><br><span class="line">        <span class="comment">// 动态注册接收者和静态接收者，这两种receiver处理的方式是不一样的，对于order广播下的动态注册</span></span><br><span class="line">        <span class="comment">// receiver而言，接收者进程一定是已经启动的，但是对于静态接收者receiver而言，当前的receiver进程</span></span><br><span class="line">        <span class="comment">// 可能还没有启动，因此动态和静态的receiver处理的逻辑不一样，需要分开处理，而静态接收者又分为进程</span></span><br><span class="line">        <span class="comment">// 已经启动和尚未启动两种情况。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">BroadcastOptions</span> <span class="variable">brOptions</span> <span class="operator">=</span> r.options;</span><br><span class="line">        <span class="comment">// 得到下一个广播接收者</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">nextReceiver</span> <span class="operator">=</span> r.receivers.get(recIdx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前nextReceiver是一个BroadcastFilter类型，说名是一个动态注册接收者，不需要启动一个进程,</span></span><br><span class="line">        <span class="comment">// 直接调用deliverToRegisteredReceiverLocked函数发送广播</span></span><br><span class="line">        <span class="keyword">if</span> (nextReceiver <span class="keyword">instanceof</span> BroadcastFilter) &#123;</span><br><span class="line">            <span class="comment">// Simple case: this is a registered receiver who gets</span></span><br><span class="line">            <span class="comment">// a direct call.</span></span><br><span class="line">            <span class="type">BroadcastFilter</span> <span class="variable">filter</span> <span class="operator">=</span> (BroadcastFilter) nextReceiver;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 上面已经分析</span></span><br><span class="line">            deliverToRegisteredReceiverLocked(r, filter, r.ordered, recIdx);</span><br><span class="line">            <span class="comment">// 检查BroadcastRecord对象r所描述的广播转发任务是否用来转发无序广播的。</span></span><br><span class="line">            <span class="keyword">if</span> (r.receiver == <span class="literal">null</span> || !r.ordered) &#123;<span class="comment">// 如果是</span></span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">// 设置IDLE状态，表示AMS不需要等待它的前一个目标广播接收者处理完成一个广播就可以将该广播</span></span><br><span class="line">                <span class="comment">// 继续发送给它的下一个目标广播接收者处理</span></span><br><span class="line">                r.state = BroadcastRecord.IDLE;</span><br><span class="line">                <span class="comment">// 调用下面函数就是为了将一个广播继续发送给BroadcastRecord对象r所描述的广播转发任务的</span></span><br><span class="line">                <span class="comment">// 下一个目标广播接收者处理的</span></span><br><span class="line">                scheduleBroadcastsLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hard case: need to instantiate the receiver, possibly</span></span><br><span class="line">        <span class="comment">// starting its application process to host it.</span></span><br><span class="line">        <span class="comment">// 如果不是动态的说明是一个静态注册接收者（如果动态的上面if中处理并进行拦截），此时进程可能没有启动</span></span><br><span class="line">        <span class="type">ResolveInfo</span> <span class="variable">info</span> <span class="operator">=</span></span><br><span class="line">                (ResolveInfo) nextReceiver;</span><br><span class="line">        <span class="type">ComponentName</span> <span class="variable">component</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComponentName</span>(</span><br><span class="line">                info.activityInfo.applicationInfo.packageName,</span><br><span class="line">                info.activityInfo.name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否跳过该广播接收者不处理</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">skip</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 得到ResolveInfo对象info所描述的广播接收者的android:process属性值，即它需要运行在的应用程序</span></span><br><span class="line">        <span class="comment">// 进程的名称，并且保存在变量targetProcess中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">targetProcess</span> <span class="operator">=</span> info.activityInfo.processName;</span><br><span class="line">        <span class="comment">// 获取当前广播接收者的进程记录，也就是该静态广播接收者是否已经运行</span></span><br><span class="line">        <span class="type">ProcessRecord</span> <span class="variable">app</span> <span class="operator">=</span> mService.getProcessRecordLocked(targetProcess,</span><br><span class="line">                info.activityInfo.applicationInfo.uid, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过，恢复初始状态，开始下一个广播接收者的处理</span></span><br><span class="line">        <span class="keyword">if</span> (skip) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r.delivery[recIdx] = BroadcastRecord.DELIVERY_DELIVERED;</span><br><span class="line">        r.state = BroadcastRecord.APP_RECEIVE;</span><br><span class="line">        r.curComponent = component;</span><br><span class="line">        r.curReceiver = info.activityInfo;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (brOptions != <span class="literal">null</span> &amp;&amp; brOptions.getTemporaryAppWhitelistDuration() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            scheduleTempWhitelistLocked(receiverUid,</span><br><span class="line">                    brOptions.getTemporaryAppWhitelistDuration(), r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Broadcast is being executed, its package can&#x27;t be stopped.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">                    r.curComponent.getPackageName(), <span class="literal">false</span>, UserHandle.getUserId(r.callingUid));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Is this receiver&#x27;s application already running?</span></span><br><span class="line">        <span class="comment">// 如果当前进程已经运行，则直接发给该进程，然后返回</span></span><br><span class="line">        <span class="keyword">if</span> (app != <span class="literal">null</span> &amp;&amp; app.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                app.addPackage(info.activityInfo.packageName,</span><br><span class="line">                        info.activityInfo.applicationInfo.versionCode, mService.mProcessStats);</span><br><span class="line">                <span class="comment">// 将广播发送给该进程处理</span></span><br><span class="line">                processCurBroadcastLocked(r, app);</span><br><span class="line">                <span class="comment">// order广播是一种同步处理方式，因此处理完可以直接return</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If a dead object exception was thrown -- fall through to</span></span><br><span class="line">            <span class="comment">// restart the application.</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 静态接收者进程尚未启动，调用AMS的startProcessLocked函数启动该接收者进程，并将当前正在等待进程</span></span><br><span class="line">        <span class="comment">// 启动的BroadcastRecord存储到mPendingBroadcast里面，这个就是静态广播拉起应用的原理，如果应用</span></span><br><span class="line">        <span class="comment">// 没有启动，注册一个静态广播（一般厂商会修改只能启动自己的应用）。到这里又开始进入等待进程启动的</span></span><br><span class="line">        <span class="comment">// 过程，进程启动完成后才能处理广播</span></span><br><span class="line">        <span class="keyword">if</span> ((r.curApp = mService.startProcessLocked(targetProcess,</span><br><span class="line">                info.activityInfo.applicationInfo, <span class="literal">true</span>,</span><br><span class="line">                r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,</span><br><span class="line">                <span class="string">&quot;broadcast&quot;</span>, r.curComponent,</span><br><span class="line">                (r.intent.getFlags() &amp; Intent.FLAG_RECEIVER_BOOT_UPGRADE) != <span class="number">0</span>, <span class="literal">false</span>, <span class="literal">false</span>))</span><br><span class="line">                == <span class="literal">null</span>) &#123;<span class="comment">// 如果启动失败</span></span><br><span class="line">            ...</span><br><span class="line">            logBroadcastReceiverDiscardLocked(r);</span><br><span class="line">            <span class="comment">// 结束广播发送任务</span></span><br><span class="line">            finishReceiverLocked(r, r.resultCode, r.resultData,</span><br><span class="line">                    r.resultExtras, r.resultAbort, <span class="literal">false</span>);</span><br><span class="line">            scheduleBroadcastsLocked();</span><br><span class="line">            r.state = BroadcastRecord.IDLE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正在启动接收者进程，将正在启动的BroadcastRecord记录存储到mPendingBroadcast中，同时将当前正在</span></span><br><span class="line">        <span class="comment">// 启动的接收者进程在所有接收者中的索引存储到mPendingBroadcastRecvIndex，如果当前广播接收者处理</span></span><br><span class="line">        <span class="comment">// 完，需要继续从mPendingBroadcastRecvIndex计算到下一个接收者发送当前广播</span></span><br><span class="line">        mPendingBroadcast = r;</span><br><span class="line">        mPendingBroadcastRecvIndex = recIdx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们根据第五步的发送消息类型可以跟踪到，消息执行是在BroadcastHandler的handleMessage方法中调用的，这里出入一个参数fromMsg，也就是该广播是不是通过Handler发送消息的方式传递的，那么我们上面知道我们这就是通过这种方式执行的，所以在代码中会将mBroadcastsScheduled参数设置为false，也就是这个消息开始执行了则开始运行下一个消息发送。还有就是通过直接调用的方式来执行的，那么就不会改变这个参数。</p>
<p>接着看，先执行无序广播，无序广播接收者不需要等待，所以直接for循环执行，调用deliverToRegisteredReceiverLocked方法发送广播。</p>
<h4 id="7、deliverToRegisteredReceiverLocked"><a href="#7、deliverToRegisteredReceiverLocked" class="headerlink" title="7、deliverToRegisteredReceiverLocked"></a>7、deliverToRegisteredReceiverLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AMS将一个广播发给一个目标广播接收者之前，有可能需要检查这个广播的发送者和接收者的权限。这个权限检查是</span></span><br><span class="line"><span class="comment">// 双向的，即需要检查一个广播发送者是否有权限向一个目标广播接收者发送广播，以及一个目标广播接收者是否有权限</span></span><br><span class="line"><span class="comment">// 接收一个广播发送者发过来的一个广播。这两个权限主要是调用AMS的成员函数checkComponentPermission来检查</span></span><br><span class="line"><span class="comment">// 对方的PID以及UID是否符合要求</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deliverToRegisteredReceiverLocked</span><span class="params">(BroadcastRecord r,</span></span><br><span class="line"><span class="params">                                               BroadcastFilter filter, <span class="type">boolean</span> ordered, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 标记是否要跳过该广播接收者</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">skip</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 需要检查广播发送者的权限</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// r.requiredPermissions != null为true表示需要检查广播接收者的权限</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 如果要跳过，则设置该广播结束</span></span><br><span class="line">    <span class="keyword">if</span> (skip) &#123;</span><br><span class="line">        r.delivery[index] = BroadcastRecord.DELIVERY_SKIPPED;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// order广播，所有的接收者需要依次以一种同步的方式发送广播，</span></span><br><span class="line">    <span class="comment">// 可以看到order广播在BroadcastRecord保存了几个状态</span></span><br><span class="line">    <span class="keyword">if</span> (ordered) &#123;</span><br><span class="line">        <span class="comment">// IBinder类型，代表当前的接收者</span></span><br><span class="line">        r.receiver = filter.receiverList.receiver.asBinder();</span><br><span class="line">        <span class="comment">// 当前正在处理的BroadcastFilter，和上面的receiver是对应好的</span></span><br><span class="line">        r.curFilter = filter;</span><br><span class="line">        filter.receiverList.curBroadcast = r;</span><br><span class="line">        r.state = BroadcastRecord.CALL_IN_RECEIVE;</span><br><span class="line">        <span class="keyword">if</span> (filter.receiverList.app != <span class="literal">null</span>) &#123;</span><br><span class="line">            r.curApp = filter.receiverList.app;</span><br><span class="line">            filter.receiverList.app.curReceiver = r;</span><br><span class="line">            mService.updateOomAdjLocked(r.curApp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (filter.receiverList.app != <span class="literal">null</span> &amp;&amp; filter.receiverList.app.inFullBackup) &#123;</span><br><span class="line">            <span class="comment">// 如果正在备份或者恢复备份跳过，</span></span><br><span class="line">            <span class="comment">// 如果是一个有序广播，则执行下一个广播</span></span><br><span class="line">            <span class="keyword">if</span> (ordered) &#123;</span><br><span class="line">                skipReceiverLocked(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不需要进行权限检查或者通过权限检查，调用performReceiveLocked发送广播</span></span><br><span class="line">            performReceiveLocked(filter.receiverList.app, filter.receiverList.receiver,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Intent</span>(r.intent), r.resultCode, r.resultData,</span><br><span class="line">                    r.resultExtras, r.ordered, r.initialSticky, r.userId);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们这里不是有序广播，正常也不会备份，所以会走else里面的方法performReceiveLocked。如果是有序广播我们后面再分析</p>
<h4 id="8、performReceiveLocked"><a href="#8、performReceiveLocked" class="headerlink" title="8、performReceiveLocked"></a>8、performReceiveLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 由前面可知，当一个Activity或者一个Service将一个广播接收者注册到AMS中时，它所在的应用程序进程会先将</span></span><br><span class="line"><span class="comment"> * 这个广播接收者封装成一个类型为InnerReceiver的Binder本地对象，然后再注册到AMS中。因此当AMS要将一个</span></span><br><span class="line"><span class="comment"> * 广播发给一个目标广播接收者处理时，实际上是将这个广播转发给封装了这个目标广播接收者的一个InnerReceiver</span></span><br><span class="line"><span class="comment"> * 对象来处理</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * AMS向一个应用程序进程发送一个广播时，采用的是异步进程间通信方式。前面提到，发送给一个Binder实体对象</span></span><br><span class="line"><span class="comment"> * 的所有异步事物都是保存在一个异步事物队列中的。由于保存在一个异步事物队列中的异步事物在同一时刻只有一</span></span><br><span class="line"><span class="comment"> * 个会得到处理，即只有队列头部的异步事物才会得到处理，因此AMS就可以保证它发送给同一个应用程序的所有广</span></span><br><span class="line"><span class="comment"> * 播都是按照这个发送顺序来串行的被接受和处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">performReceiveLocked</span><span class="params">(ProcessRecord app, IIntentReceiver receiver,</span></span><br><span class="line"><span class="params">                          Intent intent, <span class="type">int</span> resultCode, String data, Bundle extras,</span></span><br><span class="line"><span class="params">                          <span class="type">boolean</span> ordered, <span class="type">boolean</span> sticky, <span class="type">int</span> sendingUser)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// Send the intent to the receiver asynchronously using one-way binder calls.</span></span><br><span class="line">    <span class="comment">// app不为空，表示进程已经启动，调用ActivityThread.scheduleRegisteredReceiver发送当前广播</span></span><br><span class="line">    <span class="keyword">if</span> (app != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (app.thread != <span class="literal">null</span>) &#123;<span class="comment">// 因为是动态注册广播，所以一般不为空</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 这里scheduleRegisteredReceiver函数是一个Binder调用，注释上面说的很清楚，</span></span><br><span class="line">                <span class="comment">// 要用one-way calls像动态的注册进程发起Binder调用，意思就是在Binder调用里面会</span></span><br><span class="line">                <span class="comment">// 加上IBinder.FLAG_ONEWAY标记，Binder客户端（动态注册进程）只要一收到Binder调用的</span></span><br><span class="line">                <span class="comment">// 命令和数据，立马返回到Binder服务端（AMS进程），是一个异步的调用方式。</span></span><br><span class="line">                <span class="comment">// 大致流程是：</span></span><br><span class="line">                <span class="comment">// 1) ApplicationThreadNative.ApplicationThreadProxy. scheduleRegisteredReceiver(system_server)</span></span><br><span class="line">                <span class="comment">// 2) Binder驱动 (Binder驱动进程，ONEWAY)</span></span><br><span class="line">                <span class="comment">// 3)ApplicationThreadNative. scheduleRegisteredReceiver(应用进程，Binder线程向主线程发送消息)</span></span><br><span class="line">                <span class="comment">// 4)Binder驱动返回 (Binder驱动进程)</span></span><br><span class="line">                <span class="comment">// 5)ActivityThread. scheduleRegisteredReceiver(应用进程，处理消息)</span></span><br><span class="line">                <span class="comment">// 调用ApplicationThread对象的Binder代理对象的函数来向它发送广播</span></span><br><span class="line">                app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,</span><br><span class="line">                        data, extras, ordered, sticky, sendingUser, app.repProcState);</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 直接调用与它关联的一个InnerReceiver对象的Binder代理对象的成员函数performReceive来向它发送广播</span></span><br><span class="line">        receiver.performReceive(intent, resultCode, data, extras, ordered,</span><br><span class="line">                sticky, sendingUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果进程存在，则执行ActivityThread.scheduleRegisteredReceiver方法，否则直接调用receiver.performReceive方法发送广播。因为我们动态注册的所以会执行第一种情况。</p>
<h4 id="9、ActivityThread-scheduleRegisteredReceiver"><a href="#9、ActivityThread-scheduleRegisteredReceiver" class="headerlink" title="9、ActivityThread.scheduleRegisteredReceiver"></a>9、ActivityThread.scheduleRegisteredReceiver</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理非串行化动态广播,非串化ordered是false，这里的receiver对应的是</span></span><br><span class="line"><span class="comment">// LoadedApk.ReceiverDispatcher.InnerReceiver对象</span></span><br><span class="line"><span class="comment">// This function exists to make sure all receiver dispatching is</span></span><br><span class="line"><span class="comment">// correctly ordered, since these are one-way calls and the binder driver</span></span><br><span class="line"><span class="comment">// applies transaction ordering per object for such calls.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduleRegisteredReceiver</span><span class="params">(IIntentReceiver receiver, Intent intent,</span></span><br><span class="line"><span class="params">                                       <span class="type">int</span> resultCode, String dataStr, Bundle extras, <span class="type">boolean</span> ordered,</span></span><br><span class="line"><span class="params">                                       <span class="type">boolean</span> sticky, <span class="type">int</span> sendingUser, <span class="type">int</span> processState)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    updateProcessState(processState, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 调用LoadedApk.ReceiverDispatcher.InnerReceiver.performReceive函数</span></span><br><span class="line">    receiver.performReceive(intent, resultCode, dataStr, extras, ordered,</span><br><span class="line">            sticky, sendingUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们看到和上面一样最终还是执行receiver.performReceive方法来发送广播。</p>
<h4 id="10、LoadedApk-ReceiverDispatcher-InnerReceiver-performReceive"><a href="#10、LoadedApk-ReceiverDispatcher-InnerReceiver-performReceive" class="headerlink" title="10、LoadedApk.ReceiverDispatcher.InnerReceiver.performReceive"></a>10、LoadedApk.ReceiverDispatcher.InnerReceiver.performReceive</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performReceive</span><span class="params">(Intent intent, <span class="type">int</span> resultCode, String data,</span></span><br><span class="line"><span class="params">                               Bundle extras, <span class="type">boolean</span> ordered, <span class="type">boolean</span> sticky, <span class="type">int</span> sendingUser)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> LoadedApk.ReceiverDispatcher rd;</span><br><span class="line">        ...</span><br><span class="line">            rd = mDispatcher.get();</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (rd != <span class="literal">null</span>) &#123;</span><br><span class="line">            rd.performReceive(intent, resultCode, data, extras,</span><br><span class="line">                    ordered, sticky, sendingUser);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">                mgr.finishReceiver(<span class="built_in">this</span>, resultCode, data, extras, <span class="literal">false</span>, intent.getFlags());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们上一章注册广播是讲过LoadedApk.ReceiverDispatcher对象封装了广播接收者，如果该广播接收者注册了，那么该对象就会存在，则会调用LodedApk.ReceiverDispatcher.performReceive，否则调用AMS.finishReceiver方法，我们先看有广播的情况。</p>
<h4 id="11、LodedApk-ReceiverDispatcher-performReceive"><a href="#11、LodedApk-ReceiverDispatcher-performReceive" class="headerlink" title="11、LodedApk.ReceiverDispatcher.performReceive"></a>11、LodedApk.ReceiverDispatcher.performReceive</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performReceive</span><span class="params">(Intent intent, <span class="type">int</span> resultCode, String data,</span></span><br><span class="line"><span class="params">                           Bundle extras, <span class="type">boolean</span> ordered, <span class="type">boolean</span> sticky, <span class="type">int</span> sendingUser)</span> &#123;</span><br><span class="line">    <span class="comment">// 首先将参数Intent所描述的一个广播封装成一个Args对象，然后将这个Args对象封装成一个消息对象，</span></span><br><span class="line">    <span class="comment">// 然后将这个消息对象发送到应用程序主线程的消息队列中。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Args</span> <span class="variable">args</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Args</span>(intent, resultCode, data, extras, ordered,</span><br><span class="line">            sticky, sendingUser);</span><br><span class="line">    <span class="comment">// 将当前广播信息放到主线程的Handler中进行处理，作为一个Runnable调度而不是在handleMessage中处理，</span></span><br><span class="line">    <span class="comment">// 而是在Handler内部机制中，处理的时候会对应run函数，因此这里不久后会调用Args.run函数</span></span><br><span class="line">    ..</span><br><span class="line">    <span class="comment">// 上面将广播的参数封装在一个Args对象里面，然后通过post到主线程的消息队列里面</span></span><br><span class="line">    <span class="keyword">if</span> (intent == <span class="literal">null</span> || !mActivityThread.post(args)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">            ...</span><br><span class="line">            args.sendFinished(mgr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面初始化了一个Args对象，该对象实现了Runnable接口，在if语句中调用post方法，会调用Args中的run方法。</p>
<h4 id="13、Args-run"><a href="#13、Args-run" class="headerlink" title="13、Args.run"></a>13、Args.run</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// mReceiver指向一个广播接收者</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">BroadcastReceiver</span> <span class="variable">receiver</span> <span class="operator">=</span> mReceiver;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 这里处理的是动态广播接收者，默认认为接收者BroadcastReceiver已经存在</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 接受广播</span></span><br><span class="line">        receiver.onReceive(mContext, intent);</span><br><span class="line">        <span class="comment">// 然后调用BroadcastReceiver.PendingResult.finish函数，也就是下面的finish函数</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 检查当前广播是否是有序广播，并且广播接收者是否已经注册到AMS中</span></span><br><span class="line">        <span class="keyword">if</span> (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">            <span class="comment">// 通知AMS，它前面转发过来的有序广播已经处理完了，这时AMS就可以继续将这个有序广播</span></span><br><span class="line">            <span class="comment">// 转发给下一个目标广播接收者了</span></span><br><span class="line">            sendFinished(mgr);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里调用BroadcastReceiver.onReceive方法，这样就会执行完一次无需广播发送过程。我们再回到第10步，如果对象接收者不存在则调用AMS.finishReceiver</p>
<h4 id="15、AMS-finishReceiver"><a href="#15、AMS-finishReceiver" class="headerlink" title="15、AMS.finishReceiver"></a>15、AMS.finishReceiver</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finishReceiver</span><span class="params">(IBinder who, <span class="type">int</span> resultCode, String resultData,</span></span><br><span class="line"><span class="params">                           Bundle resultExtras, <span class="type">boolean</span> resultAbort, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">doNext</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        BroadcastRecord r;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先辨别出当前receiver所在的BroadcastRecord属于前台广播还是后台广播，然后在对应的</span></span><br><span class="line">        <span class="comment">// BroadcastQueue中找出对应的BroadcastRecord，里面的finishReceiverLocked函数在前面介绍过，</span></span><br><span class="line">        <span class="comment">// 主要是重新设置BroadcastRecord里面一些状态变量，以便于BroadcastRecord将广播发送给下一个</span></span><br><span class="line">        <span class="comment">// 接收者。尤其的，如果前面的mAbortBroadcast设置为true，那么BroadcastRecord的成员resultAbort</span></span><br><span class="line">        <span class="comment">// 会设置成true</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="type">BroadcastQueue</span> <span class="variable">queue</span> <span class="operator">=</span> (flags &amp; Intent.FLAG_RECEIVER_FOREGROUND) != <span class="number">0</span></span><br><span class="line">                    ? mFgBroadcastQueue : mBgBroadcastQueue;</span><br><span class="line">            r = queue.getMatchingOrderedReceiver(who);</span><br><span class="line">            <span class="comment">// 结束当前正在发送的广播</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">                doNext = r.queue.finishReceiverLocked(r, resultCode,</span><br><span class="line">                        resultData, resultExtras, resultAbort, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 立马调度一次发送广播，发送下一次广播，但是processNextBroadcast是一个同步函数，</span></span><br><span class="line">        <span class="comment">// 一次只能处理一个请求</span></span><br><span class="line">        <span class="keyword">if</span> (doNext) &#123;</span><br><span class="line">            r.queue.processNextBroadcast(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是如果发送广播时接收者不存在，那么要完成该次广播，并且判断是否执行发送给下一个广播接收者，如果需要发送给下个广播接收者要再次调用BroadcastQueue.processNextBroadcast方法。这样就又回到了前面第六步。我们再往前看BroadcastQueue.processNextBroadcast方法，执行完无序广播后开始执行有序广播，因为有序广播是一个执行完再执行下一个所以必须设置超时，并且如果超时要立即接受广播，</p>
<h4 id="17、broadcastTimeoutLocked"><a href="#17、broadcastTimeoutLocked" class="headerlink" title="17、broadcastTimeoutLocked"></a>17、broadcastTimeoutLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AMS在处理order模式广播接收者时，会为每一个order模式广播处理设置超时时间，并且超时时间是各个接收者之间</span></span><br><span class="line"><span class="comment"> * 相互独立，前面分析超时通过setBroadcastTimeoutLocked函数建立超时时间点消息的，本以为每次处理完以后，</span></span><br><span class="line"><span class="comment"> * 调用cancelBroadcastTimeoutLocked函数取消当前接收者的超时消息，但是实际上用了一种更加高效的方法处理了</span></span><br><span class="line"><span class="comment"> * 超时机制，在每个order模式receiver开始处理的时候设置超时消息，BroadcastRecord.receiverTime记录了</span></span><br><span class="line"><span class="comment"> * 当前receiver开始处理的时间点</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * BroadcastRecord超时：注意这里的超时和我们常说的广播超时ANR不是一个概念，这个BroadcastRecord超时是针</span></span><br><span class="line"><span class="comment"> * 对当前BroadcastRecord. receivers里面剩余的所有的成员而言的，比如说当前receivers里面剩余4个广播接收者，</span></span><br><span class="line"><span class="comment"> * 那么这个超时的时间： 2*(4*mTimeoutPeriod) 至于这个mTimeoutPeriod，对于前台广播mFgBroadcastQueue</span></span><br><span class="line"><span class="comment"> * 和mBgBroadcastQueue后台广播时间:BROADCAST_FG_TIMEOUT = 10 * 1000</span></span><br><span class="line"><span class="comment"> * 和BROADCAST_BG_TIMEOUT = 60 * 1000（AMS中），也就是对于有4个成员的receivers 后台广播的</span></span><br><span class="line"><span class="comment"> * BroadcastRecord而言超时的时间为：2*(4*10*1000)=80 000ms=80s，当出现这种超时的时候，当前正在处理的</span></span><br><span class="line"><span class="comment"> * 广播接收者会出现ANR，并且导致后面尚未接收到广播的收不到当前的广播。broadcastTimeoutLocked函数会将</span></span><br><span class="line"><span class="comment"> * mOrderedBroadcasts中下标为0的应用进程ANR，下面forceReceive设置为true，走到下面的if判断里面会将当前</span></span><br><span class="line"><span class="comment"> * 正在处理的BroadcastRecord从mOrderedBroadcasts中remove掉，导致receivers后面的成员没有收到广播，</span></span><br><span class="line"><span class="comment"> * 并且将r设置为null，接着就处理broadcastTimeoutLocked里面的下一个广播记录BroadcastRecord。例如，</span></span><br><span class="line"><span class="comment"> * receivers里面包含4个成员，但是第1个接收者在80s内都没有处理完，那么这个接收者进程会收到ANR，</span></span><br><span class="line"><span class="comment"> * 并且后面的3个广播接收者都收不到当前的广播。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 注释来自于：http://blog.csdn.net/houliang120/article/details/51607170</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromMsg</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">broadcastTimeoutLocked</span><span class="params">(<span class="type">boolean</span> fromMsg)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">    <span class="type">BroadcastRecord</span> <span class="variable">r</span> <span class="operator">=</span> mOrderedBroadcasts.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fromMsg) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mService.mDidDexOpt) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="type">long</span> <span class="variable">timeoutTime</span> <span class="operator">=</span> SystemClock.uptimeMillis() + mTimeoutPeriod;</span><br><span class="line">            setBroadcastTimeoutLocked(timeoutTime);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">timeoutTime</span> <span class="operator">=</span> r.receiverTime + mTimeoutPeriod;</span><br><span class="line">        <span class="comment">// 举个例子：</span></span><br><span class="line">        <span class="comment">// 假设receiverA在100s的时候开始处理，超时时间为10s，那么receiverA的超时时间点就是110s，</span></span><br><span class="line">        <span class="comment">// 但是receiverA在105s的时候已经处理完了，于是在105s的时候开始receiverB，但是并没有取消</span></span><br><span class="line">        <span class="comment">// receiverA的超时消息，也就是在110s的时候仍然会走到这里的broadcastTimeoutLocked函数，</span></span><br><span class="line">        <span class="comment">// receiverB开始处理，这时候r.receiverTime就是105s，对于receiverB而言超时时间应该是115s，</span></span><br><span class="line">        <span class="comment">// 假设receiverB需要在112s才能处理完，在110s的时候broadcastTimeoutLocked函数处理的时候</span></span><br><span class="line">        <span class="comment">// timeoutTime=115s，now=110s，这时候不会进行实际的超时处理，因为还没有到真实的超时时间，</span></span><br><span class="line">        <span class="comment">// 所以重新设置超时时间点在115s。就这样根据当前BroadcastRecord.receiverTime的时间反复调整。</span></span><br><span class="line">        <span class="keyword">if</span> (timeoutTime &gt; now) &#123;<span class="comment">// 判断超时时间点和现在时间的关系，此处还没有超时</span></span><br><span class="line">            <span class="comment">// We can observe premature timeouts because we do not cancel and reset the</span></span><br><span class="line">            <span class="comment">// broadcast timeout message after each receiver finishes.  Instead, we set up</span></span><br><span class="line">            <span class="comment">// an initial timeout then kick it down the road a little further as needed</span></span><br><span class="line">            <span class="comment">// when it expires.</span></span><br><span class="line">            <span class="comment">// 因为没有在每个广播处理完之后取消或者重置超时时间，从而导致提前检测到超时消息。取而代之，</span></span><br><span class="line">            <span class="comment">// 设置一个初始超时时间点，然后每次出现超时事件的时候根据需要进行处理或者调整超时机制。</span></span><br><span class="line">            ...</span><br><span class="line">            setBroadcastTimeoutLocked(timeoutTime);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">BroadcastRecord</span> <span class="variable">br</span> <span class="operator">=</span> mOrderedBroadcasts.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (br.state == BroadcastRecord.WAITING_SERVICES) &#123;</span><br><span class="line">        ...</span><br><span class="line">        processNextBroadcast(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要是超时的处理，因为注释已经非常详细，所以不再解释，所以我们在写广播接收到消息是最后采用Handler或者启动服务将消息处理的过程放到Handler中或者服务中，而不是直接在广播接收者中完成。</p>
<h4 id="18、setBroadcastTimeoutLocked"><a href="#18、setBroadcastTimeoutLocked" class="headerlink" title="18、setBroadcastTimeoutLocked"></a>18、setBroadcastTimeoutLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置超时时间</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setBroadcastTimeoutLocked</span><span class="params">(<span class="type">long</span> timeoutTime)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mPendingBroadcastTimeoutMessage) &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(BROADCAST_TIMEOUT_MSG, <span class="built_in">this</span>);</span><br><span class="line">        mHandler.sendMessageAtTime(msg, timeoutTime);</span><br><span class="line">        mPendingBroadcastTimeoutMessage = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果广播还没有超时就执行完了就从新设置下一个广播的起始时间，方便计算下一个广播的超时。这个消息处理就不分析了，自己看一下。再回到第六步BroadcastQueue.processNextBroadcast方法中，如果广播发送完成，或者被中断或者取消，则判断是否发送最后的广播，如果要发送，则执行performReceiveLocked方法，这个方法在第八步讲了，这里就不再重复分析。我们知道广播有静态广播接收者和动态广播接收者，动态广播接收者进程都是启动的，但是静态的就不一定了，可能进程还没有启动，就想第六步中代码注释分析的一样，我们上面处理的都是动态注册的，不需要判断进程是否已经启动，但是静态广播就需要判断该进程是否已经启动了。这里的ResolveInfo表示静态广播接收者对象。找到对象后判断是否要跳过该广播，如果跳过则通过执行scheduleBroadcastsLocked方法发送消息执行下一个广播。如果不需要跳过该广播时，判断该进程是否存在，如果该静态广播的进程已经存在了则执行processCurBroadcastLocked，将广播发送给该进程处理，如果不存在则启动进程，并且将广播对象BroadcastRecord放入等待广播列表中，如果启动失败则接受该广播并判断是否执行下一个广播，我们先将一下进程存在时广播的处理，最后再分析进程启动时的广播处理。</p>
<h4 id="21、processCurBroadcastLocked"><a href="#21、processCurBroadcastLocked" class="headerlink" title="21、processCurBroadcastLocked"></a>21、processCurBroadcastLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里只是将广播发送到接收者进程，需要一直等待接收者进程处理完广播后返回，AMS才能处理当前BroadcastRecord</span></span><br><span class="line"><span class="comment">// 里面的下一个receiver，所以直接返回就行了，反正需要等待的。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">processCurBroadcastLocked</span><span class="params">(BroadcastRecord r,</span></span><br><span class="line"><span class="params">                                             ProcessRecord app)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将进程的相关信息写入当前BroadcastRecord中相关的接收者</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 处理广播，等待接收进程的返回</span></span><br><span class="line">        app.thread.scheduleReceiver(<span class="keyword">new</span> <span class="title class_">Intent</span>(r.intent), r.curReceiver,</span><br><span class="line">                mService.compatibilityInfoForPackageLocked(r.curReceiver.applicationInfo),</span><br><span class="line">                r.resultCode, r.resultData, r.resultExtras, r.ordered, r.userId,</span><br><span class="line">                app.repProcState);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用scheduleReceiver方法处理广播。</p>
<h4 id="22、ApplicationThread-scheduleReceiver"><a href="#22、ApplicationThread-scheduleReceiver" class="headerlink" title="22、ApplicationThread.scheduleReceiver"></a>22、ApplicationThread.scheduleReceiver</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理应用进程中接收到的静态广播消息，实际处理该广播的是ActivityThread.handleReceiver函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">scheduleReceiver</span><span class="params">(Intent intent, ActivityInfo info,</span></span><br><span class="line"><span class="params">                                   CompatibilityInfo compatInfo, <span class="type">int</span> resultCode, String data, Bundle extras,</span></span><br><span class="line"><span class="params">                                   <span class="type">boolean</span> sync, <span class="type">int</span> sendingUser, <span class="type">int</span> processState)</span> &#123;</span><br><span class="line">    updateProcessState(processState, <span class="literal">false</span>);</span><br><span class="line">    <span class="type">ReceiverData</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReceiverData</span>(intent, resultCode, data, extras,</span><br><span class="line">            sync, <span class="literal">false</span>, mAppThread.asBinder(), sendingUser);</span><br><span class="line">    ..</span><br><span class="line">    sendMessage(H.RECEIVER, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过Handler消息处理机制调用handleReceiver方法处理该静态广播</p>
<h4 id="23、ApplicationThread-handleReceiver"><a href="#23、ApplicationThread-handleReceiver" class="headerlink" title="23、ApplicationThread.handleReceiver"></a>23、ApplicationThread.handleReceiver</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要包括三步：</span></span><br><span class="line"><span class="comment">// 1） 创建BroadcastReceiver对象</span></span><br><span class="line"><span class="comment">// 2） 执行onReceive函数</span></span><br><span class="line"><span class="comment">// 3） 向AMS发送处理结束消息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleReceiver</span><span class="params">(ReceiverData data)</span> &#123;</span><br><span class="line">    <span class="comment">// If we are getting ready to gc after going to the background, well</span></span><br><span class="line">    <span class="comment">// we are back active so skip it.</span></span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1） 创建BroadcastReceiver对象</span></span><br><span class="line">    <span class="comment">// 这里处理的是静态广播接收者，默认认为接收者BroadcastReceiver对象不存在</span></span><br><span class="line">    <span class="comment">// 每次接受都会创建一个新的BroadcastReceiver对象</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">component</span> <span class="operator">=</span> data.intent.getComponent().getClassName();</span><br><span class="line"></span><br><span class="line">    <span class="type">LoadedApk</span> <span class="variable">packageInfo</span> <span class="operator">=</span> getPackageInfoNoCheck(</span><br><span class="line">            data.info.applicationInfo, data.compatInfo);</span><br><span class="line"></span><br><span class="line">    <span class="type">IActivityManager</span> <span class="variable">mgr</span> <span class="operator">=</span> ActivityManagerNative.getDefault();</span><br><span class="line"></span><br><span class="line">    BroadcastReceiver receiver;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 首先从AMS传递的intent中获取当前处理该广播的组件名称，然后通过反射创建一个BroadcastReceiver</span></span><br><span class="line">        <span class="comment">// 对象，从这里可以看出来，静态广播处理的时候，每次都会创建一个新的BroadcastReceiver对象；</span></span><br><span class="line">        ...</span><br><span class="line">        receiver = (BroadcastReceiver) cl.loadClass(component).newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2） 执行onReceive函数</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Application对象，如果进程已经启动，Application对象已经创建</span></span><br><span class="line">        <span class="type">Application</span> <span class="variable">app</span> <span class="operator">=</span> packageInfo.makeApplication(<span class="literal">false</span>, mInstrumentation);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 调用接收者的onReceive方法，这里还调用了setPendingResult方法，详细内容请看</span></span><br><span class="line">        <span class="comment">// BroadcastReceiver.goAsync方法。</span></span><br><span class="line">        receiver.setPendingResult(data);</span><br><span class="line">        receiver.onReceive(context.getReceiverRestrictedContext(),</span><br><span class="line">                data.intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        sCurrentBroadcastIntent.set(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3） 向AMS发送处理结束消息</span></span><br><span class="line">    <span class="keyword">if</span> (receiver.getPendingResult() != <span class="literal">null</span>) &#123;</span><br><span class="line">        data.finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面最开始注释写了这里分为三步，创建BroadcastReceiver对象，执行onReceive函数，结束。这样进程存在时静态广播就发送完成了。最后我们分析需要启动进程时发送广播的流程，我们先看一张时序图。</p>
<p><img src="/images/AndroidOS/006Broadcast/sendBroadcast2.jpg" alt="注册广播时序图"></p>
<p>在<a href="http://www.codemx.cn/2017/09/13/AndroidOS005-Process/">Android系统源码分析–Process启动过程</a>一章我们分析了进程启动过程，在最后会调用ActivityThread.mian方法，我们从这个方法开始看：</p>
<h4 id="0、ActivityThread-mian"><a href="#0、ActivityThread-mian" class="headerlink" title="0、ActivityThread.mian"></a>0、ActivityThread.mian</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动新的进程时调用Process的start方法会最终调用改函数</span></span><br><span class="line"><span class="comment"> * 启动新的进程主要做了两件事：</span></span><br><span class="line"><span class="comment"> * 1.在进程中创建了一个ActivityThread对象，并调用了它的成员函数attach向AMS发送一个启动完成的通知</span></span><br><span class="line"><span class="comment"> * 2.调用Looper类的静态成员函数prepareMainLooper创建一个消息循环，并且在向AMS发送启动完成通知后，</span></span><br><span class="line"><span class="comment"> *   使得当前进程进入到这个消息循环中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="type">ActivityThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityThread</span>();</span><br><span class="line">    thread.attach(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会初始化一个ActivityThread对象，然后调用该对象的attach方法，传入参数false。</p>
<h4 id="1、ActivityThread-attach"><a href="#1、ActivityThread-attach" class="headerlink" title="1、ActivityThread.attach"></a>1、ActivityThread.attach</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(<span class="type">boolean</span> system)</span> &#123;</span><br><span class="line">    sCurrentActivityThread = <span class="built_in">this</span>;</span><br><span class="line">    mSystemThread = system;</span><br><span class="line">    <span class="keyword">if</span> (!system) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 获取AMS的代理对象，下面会调用它的成员函数attachApplication向AMS发送一个进程间通信请求，并且</span></span><br><span class="line">        <span class="comment">// 将前面所创建的ApplicationThread（mAppThread）对象传递给AMS</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">IActivityManager</span> <span class="variable">mgr</span> <span class="operator">=</span> ActivityManagerNative.getDefault();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里向ActivityManagerService注册Client端的binder对象，它是一个binder线程</span></span><br><span class="line">            <span class="comment">// ActivityManagerService中有关Activity声明周期的消息都会发送到ActivityThread中的</span></span><br><span class="line">            <span class="comment">// 主线程mH处理</span></span><br><span class="line">            <span class="comment">// mAppThread是一个Binder本地对象，AMS是通过它来和应用进程通讯的。（AMS的代理对象类型为</span></span><br><span class="line">            <span class="comment">// ActivityManagerProxy，因此，接下来会调用ActivityManagerProxy类的成员函数向AMS发送一个</span></span><br><span class="line">            <span class="comment">// 进程间通信请求）</span></span><br><span class="line">            mgr.attachApplication(mAppThread);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// system thread</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们上面接受了传入参数是false，则会走if中的代码，也就是会执行mgr.attachApplication方法，通过注释我们知道会调用ActivityManagerProxy.attachApplication方法，然后传递到ActivityManagerService.attachApplication方法。</p>
<h4 id="2、ActivityManagerProxy-attachApplication"><a href="#2、ActivityManagerProxy-attachApplication" class="headerlink" title="2、ActivityManagerProxy.attachApplication"></a>2、ActivityManagerProxy.attachApplication</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attachApplication</span><span class="params">(IApplicationThread app)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 通过mRemote（Binder）向AMS发送一个类型为ATTACH_APPLICATION_TRANSACTION的进程间通信请求</span></span><br><span class="line">    mRemote.transact(ATTACH_APPLICATION_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、ActivityManagerService-attachApplication"><a href="#3、ActivityManagerService-attachApplication" class="headerlink" title="3、ActivityManagerService.attachApplication"></a>3、ActivityManagerService.attachApplication</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来处理ActivityMangerProxy传递过来的类型为ATTACH_APPLICATION_TRANSACTION的进程间通信请求</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">attachApplication</span><span class="params">(IApplicationThread thread)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        attachApplicationLocked(thread, callingPid);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用attachApplicationLocked方法：</p>
<h4 id="4、attachApplicationLocked"><a href="#4、attachApplicationLocked" class="headerlink" title="4、attachApplicationLocked"></a>4、attachApplicationLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">attachApplicationLocked</span><span class="params">(IApplicationThread thread,</span></span><br><span class="line"><span class="params">                                              <span class="type">int</span> pid)</span> &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Check if a next-broadcast receiver is in this process...</span></span><br><span class="line">    <span class="keyword">if</span> (!badApp &amp;&amp; isPendingBroadcastProcessLocked(pid)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            didSomething |= sendPendingBroadcastsLocked(app);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// If the app died trying to launch the receiver we declare it &#x27;bad&#x27;</span></span><br><span class="line">            Slog.wtf(TAG, <span class="string">&quot;Exception thrown dispatching broadcasts in &quot;</span> + app, e);</span><br><span class="line">            badApp = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们这里分析发送广播，所以我们只关心广播的相关处理，所以上面只保留了广播的内容，if语句中判断当前应用没有问题，并且有等待的广播，才会调用sendPendingBroadcastsLocked方法，前面我们知道静态广播有一种是进程不存在的，所以这个广播就要放到等待广播中，这里就开始处理等待广播的情况。</p>
<h4 id="5、sendPendingBroadcastsLocked"><a href="#5、sendPendingBroadcastsLocked" class="headerlink" title="5、sendPendingBroadcastsLocked"></a>5、sendPendingBroadcastsLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The app just attached; send any pending broadcasts that it should receive</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">sendPendingBroadcastsLocked</span><span class="params">(ProcessRecord app)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">didSomething</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (BroadcastQueue queue : mBroadcastQueues) &#123;</span><br><span class="line">        didSomething |= queue.sendPendingBroadcastsLocked(app);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mBroadcastQueues是包含前台优先级和后台优先级的广播队列，这里分别调用前台和后台优先级广播的BroadcastQueue.sendPendingBroadcastsLocked方法。</p>
<h4 id="6、BroadcastQueue-sendPendingBroadcastsLocked"><a href="#6、BroadcastQueue-sendPendingBroadcastsLocked" class="headerlink" title="6、BroadcastQueue.sendPendingBroadcastsLocked"></a>6、BroadcastQueue.sendPendingBroadcastsLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未启动进程的广播接收者需要先启动进程，最后到达这个函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendPendingBroadcastsLocked</span><span class="params">(ProcessRecord app)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">didSomething</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 前面分析mPendingBroadcast用于存储当前正在等待进程启动的BroadcastRecord</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">BroadcastRecord</span> <span class="variable">br</span> <span class="operator">=</span> mPendingBroadcast;</span><br><span class="line">    <span class="keyword">if</span> (br != <span class="literal">null</span> &amp;&amp; br.curApp.pid == app.pid) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 启动完成设置为null</span></span><br><span class="line">            mPendingBroadcast = <span class="literal">null</span>;</span><br><span class="line">            processCurBroadcastLocked(br, app);</span><br><span class="line">            didSomething = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是找到等待处理的广播并且判断是否为空，并且是否和当前进程的pid相同，也就是是不是找个进程的等待广播，如果是就调用processCurBroadcastLocked方法进行处理，这个方法在上面第21步中已经讲过，所以又回到了进程存在的情况下广播的处理。这样整个广播的处理就分析完了，代码量很大，但是逻辑很清楚，只需要对着注释多看看看就明白了。下一篇我们开始讲Activity启动的源码分析。</p>
<p><img src="/images/AndroidOS/006Broadcast/flowsendbroadcast.jpg" alt="发送广播流程图"></p>
<p>为了方便记忆，这里添加一个发送广播的流程图，这样对照着上面的代码流程再看就会好理解很多。</p>
<h2 id="代码地址："><a href="#代码地址：" class="headerlink" title="代码地址："></a>代码地址：</h2><p>直接拉取导入开发工具（Intellij idea或者Android studio）</p>
<p><a target="_blank" rel="noopener" href="https://github.com/yuchuangu85/Android_Framework_Source">Android_Framework_Source</a></p>
<h2 id="注"><a href="#注" class="headerlink" title="注"></a>注</h2><p>Android开发群：192508518</p>
<p>微信公众账号：Code-MX<br><img width="240" src="/images/codemx/qr_code_mx.jpg"/></p>
<p>注：本文原创，转载请注明出处，多谢。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://www.codemx.cn">墨香</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://www.codemx.cn/2017/12/25/AndroidOS007-Broadcast2/">http://www.codemx.cn/2017/12/25/AndroidOS007-Broadcast2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.codemx.cn" target="_blank">墨香博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/AndroidOS/">AndroidOS</a></div><div class="post-share"><div class="social-share" data-image="/img/head.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="prev-post pull-left" href="/2018/01/26/AndroidOS008-Activity/" title="Android系统源码分析--Activity启动过程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android系统源码分析--Activity启动过程</div></div></a><a class="next-post pull-right" href="/2017/12/21/AndroidOS006-Broadcast1/" title="Android系统源码分析--Broadcast注册和注销"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android系统源码分析--Broadcast注册和注销</div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a href="/2017/06/03/AndroidOS001/" title="IntelliJ IDEA导入Android源码"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-06-03</div><div class="title">IntelliJ IDEA导入Android源码</div></div></a><a href="/2017/06/05/AndroidOS002-Context/" title="Android系统源码分析--Context"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-06-05</div><div class="title">Android系统源码分析--Context</div></div></a><a href="/2017/07/12/AndroidOS003-SystemServer/" title="Android系统源码分析--Zygote和SystemServer启动过程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-07-12</div><div class="title">Android系统源码分析--Zygote和SystemServer启动过程</div></div></a><a href="/2017/09/13/AndroidOS005-Process/" title="Android系统源码分析--Process启动过程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-09-13</div><div class="title">Android系统源码分析--Process启动过程</div></div></a><a href="/2017/12/21/AndroidOS006-Broadcast1/" title="Android系统源码分析--Broadcast注册和注销"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-12-21</div><div class="title">Android系统源码分析--Broadcast注册和注销</div></div></a><a href="/2017/07/13/AndroidOS004-HandleMessageLooper/" title="Android系统源码分析--消息循环机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-07-13</div><div class="title">Android系统源码分析--消息循环机制</div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">墨香</div><div class="author-info-description">因为兴趣所以选择，因为选择所以坚持。</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yuchuangu85"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/yuchuangu85" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:yuchuangu85@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">路虽远，行则将至；事虽难，做则可成。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#0%E3%80%81ContextImpl-sendBroadcast"><span class="toc-number">1.</span> <span class="toc-text">0、ContextImpl.sendBroadcast</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81ActivityManagerProxy-broadcastIntent"><span class="toc-number">2.</span> <span class="toc-text">1、ActivityManagerProxy.broadcastIntent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81ActivityManagerService-broadcastIntent"><span class="toc-number">3.</span> <span class="toc-text">2、ActivityManagerService.broadcastIntent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81ActivityManagerService-broadcastIntentLocked"><span class="toc-number">4.</span> <span class="toc-text">3、ActivityManagerService.broadcastIntentLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81AMS-broadcastQueueForIntent"><span class="toc-number">5.</span> <span class="toc-text">4、AMS.broadcastQueueForIntent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81BroadcastQueue-scheduleBroadcastsLocked"><span class="toc-number">6.</span> <span class="toc-text">5、BroadcastQueue.scheduleBroadcastsLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81BroadcastQueue-processNextBroadcast"><span class="toc-number">7.</span> <span class="toc-text">6、BroadcastQueue.processNextBroadcast</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81deliverToRegisteredReceiverLocked"><span class="toc-number">8.</span> <span class="toc-text">7、deliverToRegisteredReceiverLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81performReceiveLocked"><span class="toc-number">9.</span> <span class="toc-text">8、performReceiveLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81ActivityThread-scheduleRegisteredReceiver"><span class="toc-number">10.</span> <span class="toc-text">9、ActivityThread.scheduleRegisteredReceiver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81LoadedApk-ReceiverDispatcher-InnerReceiver-performReceive"><span class="toc-number">11.</span> <span class="toc-text">10、LoadedApk.ReceiverDispatcher.InnerReceiver.performReceive</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E3%80%81LodedApk-ReceiverDispatcher-performReceive"><span class="toc-number">12.</span> <span class="toc-text">11、LodedApk.ReceiverDispatcher.performReceive</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E3%80%81Args-run"><span class="toc-number">13.</span> <span class="toc-text">13、Args.run</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15%E3%80%81AMS-finishReceiver"><span class="toc-number">14.</span> <span class="toc-text">15、AMS.finishReceiver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17%E3%80%81broadcastTimeoutLocked"><span class="toc-number">15.</span> <span class="toc-text">17、broadcastTimeoutLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18%E3%80%81setBroadcastTimeoutLocked"><span class="toc-number">16.</span> <span class="toc-text">18、setBroadcastTimeoutLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21%E3%80%81processCurBroadcastLocked"><span class="toc-number">17.</span> <span class="toc-text">21、processCurBroadcastLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22%E3%80%81ApplicationThread-scheduleReceiver"><span class="toc-number">18.</span> <span class="toc-text">22、ApplicationThread.scheduleReceiver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23%E3%80%81ApplicationThread-handleReceiver"><span class="toc-number">19.</span> <span class="toc-text">23、ApplicationThread.handleReceiver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#0%E3%80%81ActivityThread-mian"><span class="toc-number">20.</span> <span class="toc-text">0、ActivityThread.mian</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81ActivityThread-attach"><span class="toc-number">21.</span> <span class="toc-text">1、ActivityThread.attach</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81ActivityManagerProxy-attachApplication"><span class="toc-number">22.</span> <span class="toc-text">2、ActivityManagerProxy.attachApplication</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81ActivityManagerService-attachApplication"><span class="toc-number">23.</span> <span class="toc-text">3、ActivityManagerService.attachApplication</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81attachApplicationLocked"><span class="toc-number">24.</span> <span class="toc-text">4、attachApplicationLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81sendPendingBroadcastsLocked"><span class="toc-number">25.</span> <span class="toc-text">5、sendPendingBroadcastsLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81BroadcastQueue-sendPendingBroadcastsLocked"><span class="toc-number">26.</span> <span class="toc-text">6、BroadcastQueue.sendPendingBroadcastsLocked</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9C%B0%E5%9D%80%EF%BC%9A"><span class="toc-number"></span> <span class="toc-text">代码地址：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8"><span class="toc-number"></span> <span class="toc-text">注</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/17/ANR01/" title="ANR-分类以及分析流程">ANR-分类以及分析流程</a><time datetime="2024-08-17T15:24:39.000Z" title="发表于 2024-08-17 23:24:39">2024-08-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/01/Google-App-architecture/" title="Google官方Android开发资料整理之-App architecture(架构)">Google官方Android开发资料整理之-App architecture(架构)</a><time datetime="2024-07-01T15:51:46.000Z" title="发表于 2024-07-01 23:51:46">2024-07-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/01/Kotlin-Coroutines/" title="Kotlin-Coroutines">Kotlin-Coroutines</a><time datetime="2024-07-01T15:41:34.000Z" title="发表于 2024-07-01 23:41:34">2024-07-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/03/Google-Jetpack-Compose/" title="Google官方Android开发资料整理之-Jetpack Compose">Google官方Android开发资料整理之-Jetpack Compose</a><time datetime="2023-07-03T14:29:43.000Z" title="发表于 2023-07-03 22:29:43">2023-07-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/06/22/Google-Dev/" title="Google官方Android开发资料整理之-总汇">Google官方Android开发资料整理之-总汇</a><time datetime="2023-06-21T16:22:23.000Z" title="发表于 2023-06-22 00:22:23">2023-06-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2016 - 2024 By 墨香</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>